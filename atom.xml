<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eoccc的博客</title>
  
  
  <link href="https://eoccc.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://eoccc.gitee.io/"/>
  <updated>2023-02-07T03:49:44.798Z</updated>
  <id>https://eoccc.gitee.io/</id>
  
  <author>
    <name>Eoccc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM虚拟机-ZGC</title>
    <link href="https://eoccc.gitee.io/2022/12/08/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA-ZGC/"/>
    <id>https://eoccc.gitee.io/2022/12/08/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA-ZGC/</id>
    <published>2022-12-08T07:25:43.000Z</published>
    <updated>2023-02-07T03:49:44.798Z</updated>
    
    <content type="html"><![CDATA[<p>ZGC(Z Garbage Collector)是一款在JDK 11中新加入的具有实验性质的低延迟垃圾收集器。</p><span id="more"></span><p>ZGC希望在尽可能对吞吐量影响不太大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在10ms以内的低延迟。</p><p>ZGC基于Region内存布局，(暂时) 不设分代，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法。</p><h1 id="内存布局"><a class="markdownIt-Anchor" href="#内存布局"></a> 内存布局</h1><p>ZGC采用基于Region的堆内存布局，ZGC的Region具有动态性——动态创建和销毁，以及动态的区域容量大小。在x64硬件平台下，ZGC的Region可以具有如图3-19所示的大、中、小三类容量：</p><ul><li>小型Region：容量为2MB，用于放置小于256KB的小对象</li><li>中型Region：容量为32MB，用于放置大于等于256KB，小于4MB的对象</li><li>大型Region：容量不固定，可以动态变化，但必须为2MB的整数倍。用于放置大于4MB的大对象。大型Region不会被重分配。</li></ul><h1 id="染色指针"><a class="markdownIt-Anchor" href="#染色指针"></a> 染色指针</h1><p>ZGC收集器有一个标志性的设计是它采用的染色指针技术(Colored Pointer)，直接将少量额外的信息存储在指针上。</p><p>Linux下64位指针的高18位不能用来寻址，但剩余的46位指针所能支持的64T B内存在今天仍然能够充分满足大型服务器的需要。鉴于此，ZGC的染色指针技术继续盯上了这剩下的46位指针宽度，将其高4位提取出来存储四个标志信息。通过这些标志位，虚拟机可以直接从指针中看到其引用对 象的三色标记状态、是否进入了重分配集(即被移动过)、是否只能通过finaliz e()方法才能被访问 到，如图3-20所示。当然，由于这些标志位进一步压缩了原本就只有46位的地址空间，也直接导致ZGC能够管理的内存不可以超过4TB(2的42次幂)。</p><p><img src="https://gitee.com/eoccc/pic-shack/raw/master/image-20221211183456746.png" alt="image-20221211183456746"></p><p>虽然染色指针有4TB的内存限制，不能支持32位平台，不能支持压缩指针(-XX:+UseCompressedOops)等诸多约束，但它带来的收益也是非常可观的：</p><ol><li>一旦某个Region的存活对象被移走以后，这个region可以立即被释放掉，而不必等整个堆中所有指向该Region的引用都被修正后才能清理。（好处：ZGC只要有一个空闲的Region，就能够完成收集。）</li><li>可以减少在垃圾收集过程中内存屏障的使用，提高性能。设置内存屏障，尤其是写屏障的目的通常是为了记录对象引用的变动情况，如果将这些信息直接维护在指针中，显然就可以省去一些 专门的记录操作。（实际上，到目前为止ZGC都并未使用任何写屏障，只使用了读屏障。）</li><li>染色指针可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。比如可以开发Linux下的64位指针中剩余的18位，用来记录一些其他信息。</li></ol><h1 id="垃圾回收"><a class="markdownIt-Anchor" href="#垃圾回收"></a> 垃圾回收</h1><p>ZGC的垃圾回收过程大致可划分为四个大的阶段。全部四个阶段都是可以并发执行的，仅是两个阶段中间会存在短暂的停顿小阶段。</p><p><img src="https://gitee.com/eoccc/pic-shack/raw/master/image-20221211202804016.png" alt="image-20221211202804016"></p><ol><li><p>并发标记</p><p>遍历对象图做可达性分析，类似于G1，也会经过初始标记、最终标记的短暂STW，但是ZGC的标记是在指针上完成的，而不是在对象上。</p></li><li><p>并发预备重分配</p><p>根据特定的查询条件统计出本次收集过程要清理哪些region，这些region组成重分配集（Relocation Set），注意，ZGC每次回收都会扫描所有的region，用更大范围的扫描成本替换G1中的记忆集的维护成本。重分配集里面的对象会被复制到其他region中，里面的region会被释放。</p></li><li><p>并发重分配</p><p>把重分配集中的存活对象复制到新的region上，并为重分配集中的每个region维护一个转发表，记录从旧对象到新对象的转向关系。</p><p>ZGC根据染色指针就能知道一个对象是否处于重分配集中，当访问这个对象的时候，会被读内存屏障捕获，然后根据转发表将访问转发到新的对象上，同时更新引用的值（ZGC将这一过程称为“自愈”，类似于redis的rehash过程）。</p></li><li><p>并发重映射</p><p>修正重分配集中存活对象的引用，但是这个阶段ZGC并没有主动去完成，而是放在了下一次GC的并发标记阶段，反正并发标记的时候要遍历堆的所有对象。</p></li></ol><h1 id="zgc的缺点"><a class="markdownIt-Anchor" href="#zgc的缺点"></a> ZGC的缺点</h1><ol><li><p>没有分代</p><p>ZGC没有引入分代，每次回收都需要扫描整个堆的所有对象。</p></li><li><p>浮动垃圾</p><p>ZGC每次都会对整个堆进行回收，回收垃圾的整个过程耗时较长，并发标记的时候会产生浮动垃圾，如果系统持续高速的产生浮动垃圾的话，回收到的内存空间持续小于回收期间产生的浮动垃圾占用的空间，就会导致堆可用的空间越来越小，最终OOM。目前唯一的办法就是增加堆的容量，让ZGC获得更多的喘息空间。</p><p>要根本解决这个问题，还是得引入分代，让新对象在一个专门的区域中创建，然后对这块区域进行频率更高、更快的收集。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;ZGC(Z Garbage Collector)是一款在JDK 11中新加入的具有实验性质的低延迟垃圾收集器。&lt;/p&gt;</summary>
    
    
    
    
    <category term="JVM" scheme="https://eoccc.gitee.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM虚拟机-jdk工具</title>
    <link href="https://eoccc.gitee.io/2022/12/04/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA-jdk%E5%B7%A5%E5%85%B7/"/>
    <id>https://eoccc.gitee.io/2022/12/04/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA-jdk%E5%B7%A5%E5%85%B7/</id>
    <published>2022-12-04T07:25:43.000Z</published>
    <updated>2023-03-10T09:49:12.146Z</updated>
    
    <content type="html"><![CDATA[<p>JDK自带了很多小工具，打包、部署、签名、调试、监控、运维等 各种场景都可能会用到它们。</p><span id="more"></span><h1 id="jps虚拟机进程状态"><a class="markdownIt-Anchor" href="#jps虚拟机进程状态"></a> jps：虚拟机进程状态</h1><p>jps类似于linux的ps命令，可以列出正在运行的虚拟机进程，显示主类的名称及该进程的id。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps [options] [hostid]</span><br></pre></td></tr></table></figure><p>列出java进程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">jps -l</span></span><br><span class="line">22407 org.jetbrains.jps.cmdline.Launcher</span><br><span class="line">22408 com.intellij.rt.junit.JUnitStarter</span><br><span class="line">22415 jdk.jcmd/sun.tools.jps.Jps</span><br></pre></td></tr></table></figure><p>jps还可以通过RMI协议查询开启了RMI服务的远程虚拟机进程状态，hostid的定义：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;hostid&gt;:      &lt;hostname&gt;[:&lt;port&gt;]</span><br></pre></td></tr></table></figure><p>jps可选参数：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-q</td><td>只列出进程id</td></tr><tr><td>-m</td><td>输出虚拟机进程启动时传给主类main函数的参数</td></tr><tr><td>-l</td><td>输出主类的全名，如果进程执行的是jar包，则数据jar的路径</td></tr><tr><td>-v</td><td>输出jvm虚拟机的执行参数</td></tr></tbody></table><h1 id="jstat虚拟机统计信息监视工具"><a class="markdownIt-Anchor" href="#jstat虚拟机统计信息监视工具"></a> jstat：虚拟机统计信息监视工具</h1><p>Jstat可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat [ option vmid [interval[s|ms] [count]] ]</span><br></pre></td></tr></table></figure><p>vmid：对于本地虚拟机进程，填LVMID就可以；对于远程虚拟机，格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[protocol:][//]lvmid[@hostname[:port]/servername]</span><br></pre></td></tr></table></figure><p>参数int erval和count 代表查询间隔和次数，如果省略这2个参数，说明只查询一次。假设需要每250 毫秒查询一次进程2764垃圾收集状况，一共查询20次，那命令应当是:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc 2764 250 20</span><br></pre></td></tr></table></figure><p>选项option代表用户希望查询的虚拟机信息，主要分为三类：类加载、垃圾收集、运行期编译状况。</p><p><img src="/.io//image-20221213102254091.png" alt="image-20221213102254091"></p><h1 id="jinfo-java配置信息工具"><a class="markdownIt-Anchor" href="#jinfo-java配置信息工具"></a> jinfo: Java配置信息工具</h1><p>实时查看和调整虚拟机各项参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo [ option ] pid</span><br></pre></td></tr></table></figure><p>jinfo还可以使用-sysprops选项把虚拟机 进程的System.getProperties()的内容打印出来。</p><p>jinfo还可以在运行期 修改部分参数值。</p><h1 id="jmap-java内存映像工具"><a class="markdownIt-Anchor" href="#jmap-java内存映像工具"></a> jmap: Java内存映像工具</h1><p>生成堆转储快照(一般称为heapdump或dump文件)。可以查询finaliz e执行队列、Java堆和方法区的 详细信息，如空间使用率、当前用的是哪种收集器等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap [ option ] vmid</span><br></pre></td></tr></table></figure><p>如果不使用jmap 命令，要想获取Java堆转储快照可以使用-XX:+HeapDumpOnOutOfMemoryError参数，让虚拟机在内存溢出异常出现之后自动生成堆转储快照文件，或者使用-XX:+HeapDumpOnCtrlBreak参数，然后使用kill -3让虚拟机生成堆转储快照。</p><p><img src="https://gitee.com/eoccc/pic-shack/raw/master/image-20221213192925832.png" alt="image-20221213192925832"></p><h1 id="jhat-虚拟机堆转储快照分析工具"><a class="markdownIt-Anchor" href="#jhat-虚拟机堆转储快照分析工具"></a> jhat: 虚拟机堆转储快照分析工具</h1><p>与jmap搭配使用，来分析jmap生成的堆转储快照。内置了一个微型的HTTP/Web服务器，可以通过<a href="http://localhost:7000/%E6%9F%A5%E7%9C%8B%E5%88%86%E6%9E%90%E7%BB%93%E6%9E%9C%E3%80%82">http://localhost:7000/查看分析结果。</a></p><p>jhat的分析功能相对来说比较简陋，可以使用其他的分析工具如VisualVM，以及专业用于分析堆转储快照文件的EclipseMemoryAnalyzer、IBMHeapAnalyzer等工具。</p><h1 id="jstack-java堆栈跟踪工具"><a class="markdownIt-Anchor" href="#jstack-java堆栈跟踪工具"></a> jstack: Java堆栈跟踪工具</h1><p>用于生成虚拟机当前时刻的线程快照(一般称为threaddump或者 javacore文件)。通常可以用于定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间挂起等，都是导致线程长时间停顿的常见原因。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack [ option ] vmid</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/eoccc/pic-shack/raw/master/image-20221213193724742.png" alt="image-20221213193724742"></p><h1 id="jdk日志参数"><a class="markdownIt-Anchor" href="#jdk日志参数"></a> JDK日志参数</h1><p><img src="https://gitee.com/eoccc/pic-shack/raw/master/image-20221213100624431.png" alt="image-20221213100624431"></p><p><img src="/.io//image-20221213100659078.png" alt="image-20221213100659078"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;JDK自带了很多小工具，打包、部署、签名、调试、监控、运维等 各种场景都可能会用到它们。&lt;/p&gt;</summary>
    
    
    
    
    <category term="JVM" scheme="https://eoccc.gitee.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Mysql知识整理</title>
    <link href="https://eoccc.gitee.io/2022/11/02/Mysql%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <id>https://eoccc.gitee.io/2022/11/02/Mysql%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</id>
    <published>2022-11-02T07:25:19.000Z</published>
    <updated>2022-11-03T07:53:39.289Z</updated>
    
    <content type="html"><![CDATA[<p>整理一些mysql的知识。</p><span id="more"></span><h1 id="mysql"><a class="markdownIt-Anchor" href="#mysql"></a> Mysql</h1><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzxm7fsb8hj217e0tudmw.jpg" alt="image-20220304095609124"></p><h2 id="不常用sql语法"><a class="markdownIt-Anchor" href="#不常用sql语法"></a> 不常用sql语法</h2><h3 id="创建数据库"><a class="markdownIt-Anchor" href="#创建数据库"></a> 创建数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database name;</span><br></pre></td></tr></table></figure><h3 id="创建table"><a class="markdownIt-Anchor" href="#创建table"></a> 创建table</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> name (</span><br><span class="line"># 字段</span><br><span class="line">)engine<span class="operator">=</span>Innodb <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><h3 id="更改table名"><a class="markdownIt-Anchor" href="#更改table名"></a> 更改table名</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> name rename <span class="keyword">to</span> newName;</span><br></pre></td></tr></table></figure><h3 id="更改字段类型"><a class="markdownIt-Anchor" href="#更改字段类型"></a> 更改字段类型</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tableName modify columName newType <span class="keyword">not</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3 id="更改字段名称及类型"><a class="markdownIt-Anchor" href="#更改字段名称及类型"></a> 更改字段名称及类型</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tableName change columName newName newType <span class="keyword">not</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3 id="创建用户"><a class="markdownIt-Anchor" href="#创建用户"></a> 创建用户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;demo&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;demo&#x27;</span>;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">on</span> users.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;demo&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><h3 id="drop-delete与truncate"><a class="markdownIt-Anchor" href="#drop-delete与truncate"></a> drop、delete与truncate</h3><table><thead><tr><th></th><th>delete</th><th>truncate</th><th>drop</th></tr></thead><tbody><tr><td>回滚</td><td>可回滚</td><td>不可回滚</td><td>不可回滚</td></tr><tr><td>删除内容</td><td>保留表结构，删除一条或多条记录</td><td>保留表结构，删除所有记录</td><td>从数据库中删除表，删除所有的记录、索引、权限</td></tr><tr><td>删除速度</td><td>删除速度慢，需要逐行删除</td><td>删除速度快</td><td>删除速度最快</td></tr></tbody></table><h2 id="索引"><a class="markdownIt-Anchor" href="#索引"></a> 索引</h2><h3 id="什么是索引"><a class="markdownIt-Anchor" href="#什么是索引"></a> 什么是索引</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">索引是一种特殊的文件，包含对数据表里所有记录的引用指针；</span><br><span class="line">索引是一种数据结构，通常使用B树或B+树实现，用来协助快速地查询、更新数据库；</span><br><span class="line">通俗的说，索引就是为了快速的查询和更新数据库而建立的一种目录，存储于文件中，需要占用物理空间。</span><br></pre></td></tr></table></figure><h3 id="索引的优缺点"><a class="markdownIt-Anchor" href="#索引的优缺点"></a> 索引的优缺点</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line"><span class="bullet">  1.</span> 可以加快检索数据的速度</span><br><span class="line"><span class="bullet">  2.</span> 可以加速表与表之间的连接</span><br><span class="line"><span class="bullet">  3.</span> 提升排序和分组的性能</span><br><span class="line"><span class="bullet">  4.</span> 查询过程中，通过索引使用优化隐藏器，提升系统性能</span><br><span class="line"><span class="bullet">  6.</span> 通过创建唯一索引，保证数据的唯一性</span><br><span class="line">缺点：</span><br><span class="line"><span class="bullet">  1.</span> 创建和维护索引都需要时间，耗费的时间随数据量增加而增加</span><br><span class="line"><span class="bullet">  2.</span> 插入、修改和删除数据都需要维护索引，会降低数据库的更新速度</span><br><span class="line"><span class="bullet">  3.</span> 索引需要占用物理空间，随数据量的增加而增加</span><br></pre></td></tr></table></figure><h3 id="有哪些索引"><a class="markdownIt-Anchor" href="#有哪些索引"></a> 有哪些索引</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**主键索引**</span>不允许重复，不允许null值，一个表只能有一个主键索引</span><br><span class="line"><span class="strong">**唯一索引**</span> 与单列索引类似，但是<span class="strong">**索引列的值必须唯一，允许出现一个null值**</span></span><br><span class="line"><span class="strong">**普通索引（单列索引）**</span> 是最基本的索引，没有任何限制。</span><br><span class="line"><span class="strong">**组合索引**</span> 在多个字段上创建的索引。遵守最左前缀原则，即<span class="strong">**在查询语句中用到复合索引的第一个字段，索引才会被使用**</span></span><br><span class="line"><span class="strong">**全文索引**</span> 与其他索引不一样，更像是一个搜索引擎，主要用来查找文本中的关键字，而不是直接与索引中的值进行比较</span><br></pre></td></tr></table></figure><h3 id="非聚簇索引一定会回表查询吗"><a class="markdownIt-Anchor" href="#非聚簇索引一定会回表查询吗"></a> 非聚簇索引一定会回表查询吗</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不一定，当查询语句需要查询的字段全部命中索引，就不需要回表查询。</span><br></pre></td></tr></table></figure><h3 id="索引失效的情况"><a class="markdownIt-Anchor" href="#索引失效的情况"></a> 索引失效的情况？</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 在where后使用or，导致索引失效（尽量少用or）</span><br><span class="line"><span class="bullet">2.</span> 使用like，like查询是以%开头</span><br><span class="line"><span class="bullet">3.</span> 复合索引遵守“最左前缀”原则，即在查询条件中使用了复合索引的第一个字段，索引才会被使用</span><br><span class="line"><span class="bullet">4.</span> 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引</span><br><span class="line"><span class="bullet">5.</span> 使用in导致索引失效</span><br><span class="line"><span class="bullet">6.</span> DATE<span class="emphasis">_FORMAT()格式化时间，格式化后的时间再去比较，可能会导致索引失效。</span></span><br></pre></td></tr></table></figure><h3 id="设计索引的原则"><a class="markdownIt-Anchor" href="#设计索引的原则"></a> 设计索引的原则</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.最左匹配原则</span><br><span class="line">2.对频繁的查询条件字段加索引</span><br><span class="line">3.更新频繁的字段不要加索引</span><br><span class="line">4.对区分度高的字段加索引</span><br><span class="line">5.尽量拓展索引，而不是新增索引。如已经有a索引，要加(a,b)索引，应该修改a索引</span><br><span class="line">6.定义有外键的数据一定要加索引</span><br><span class="line">7.使用短索引，如果要对长字符串加索引，尽量限制前缀长度</span><br><span class="line">8.不要过度加索引</span><br><span class="line">9.不要对text、image和bit加索引</span><br></pre></td></tr></table></figure><h3 id="最左前缀原则"><a class="markdownIt-Anchor" href="#最左前缀原则"></a> 最左前缀原则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。</span><br><span class="line">2.mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</span><br><span class="line">3.=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</span><br></pre></td></tr></table></figure><h3 id="innodb-索引如何实现"><a class="markdownIt-Anchor" href="#innodb-索引如何实现"></a> InnoDB 索引如何实现</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">（1）B+树，减少IO次数。一个节点就是一页的大小，而索引中B+树，它的层级一般是3层，也就意味着我们需要3次IO</span><br><span class="line">（2）叶子节点有链表，节点包含数据行的所有信息，加快区间访问速度</span><br><span class="line">（3）主键索引、辅助索引的区别？（叶子节点存什么）</span><br><span class="line"><span class="code">聚集索引：表中行的物理顺序与键值的逻辑（索引）顺序相同。叶子节点包含数据行的所有信息。一个表只能包含一个聚集索引，提供更快的数据访问速度，适用于很少对基表进行增删改操作的情况。</span></span><br><span class="line"><span class="code">    二级索引：又叫辅助索引、非聚集索引。B+tree结构，但是叶子节点保存的是&lt;键值，主键值&gt;</span></span><br><span class="line"><span class="code">InnoDB的主键索引是聚集索引，即包含了数据行的所有信息。</span></span><br><span class="line"><span class="code">InnoDB的二级索引（辅助索引）叶子包含的数据就是该行的主键。</span></span><br><span class="line"><span class="code">（4）InnoDB这么设计是利用了缓存机制，减少IO访问次数</span></span><br></pre></td></tr></table></figure><h3 id="执行计划"><a class="markdownIt-Anchor" href="#执行计划"></a> 执行计划</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">explain  查询语句会得到如下信息：</span><br><span class="line"><span class="code">table | type | possible_keys | key | key_len | ref | rows | Extra</span></span><br><span class="line"><span class="code">table：显示这一行的数据是关于哪张表的</span></span><br><span class="line"><span class="code">type：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index和ALL</span></span><br><span class="line"><span class="code">possible_keys：显示可能应用在这张表中的索引。</span></span><br><span class="line"><span class="code">**key：**实际使用的索引，查看是否使用我们想要的key</span></span><br><span class="line"><span class="code">key_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好</span></span><br><span class="line"><span class="code">ref：显示索引的哪一列被使用了，如果可能的话，是一个常数</span></span><br><span class="line"><span class="code">rows：MYSQL认为必须检查的用来返回请求数据的行数</span></span><br><span class="line"><span class="code">**extra：**是否有耗性能的操作，比如：</span></span><br><span class="line"><span class="code">Using filesort: mysql需要进行额外的步骤来发现如何对返回的行排序</span></span><br><span class="line"><span class="code">Using temporary: mysql需要创建一个临时表来存储结果</span></span><br></pre></td></tr></table></figure><h3 id="sql如何调优"><a class="markdownIt-Anchor" href="#sql如何调优"></a> SQL如何调优</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">（1）查看执行计划（如上）</span><br><span class="line">（2）优化索引</span><br><span class="line">最左前缀原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配</span><br><span class="line">覆盖索引，索引中包含了满足查询语句中字段与条件的数据，避免回表查询</span><br><span class="line">使用索引排序，而不是file sort</span><br><span class="line">主键使用合适的数据类型</span><br><span class="line">选用区分度较高的索引</span><br><span class="line">（3）反范式设计</span><br><span class="line">在表里增加一些与主键不直接相关的列</span><br><span class="line">（4）Join内连接的优化</span><br><span class="line">小表驱动大表（Mysql优化器可优化、减少循环次数），在被驱动表中连接的字段要走索引。EXPLAIN结果中，第一行出现的表就是驱动表</span><br><span class="line">（4）万变不离其宗，主要就是为了减少IO次数</span><br><span class="line"></span><br><span class="line">具体的：</span><br><span class="line"><span class="bullet">1.</span> 指定查询的列，只查询需要的结果，避免查询所有列</span><br><span class="line"><span class="bullet">2.</span> 使用覆盖索引，避免回表查询</span><br><span class="line"><span class="bullet">3.</span> 空值判断使用<span class="code">`is not null`</span>， 使用<span class="code">`is null`</span>会导致全表扫描</span><br><span class="line"><span class="bullet">4.</span> 使用组合索引要注意最左前缀原则</span><br><span class="line"><span class="bullet">5.</span> where、order by、group、多表连接条件中的字段应该创建索引</span><br><span class="line"><span class="bullet">6.</span> 使用like匹配时，通配符%不能放在最前</span><br><span class="line"><span class="bullet">7.</span> 分页查询不要使用offset，而是使用范围查询+limit</span><br><span class="line"><span class="bullet">8.</span> 避免对查询条件使用函数，会导致索引失效</span><br><span class="line"><span class="bullet">9.</span> 隐式转换会导致索引失效</span><br><span class="line"><span class="bullet">10.</span> 避免使用or，会导致索引失效，而应该用union连接</span><br></pre></td></tr></table></figure><h3 id="b树和b树的区别"><a class="markdownIt-Anchor" href="#b树和b树的区别"></a> B树和B+树的区别</h3><table><thead><tr><th>B树</th><th>B+树</th></tr></thead><tbody><tr><td>有k个元素的中间节点包含k+1个子树</td><td>有k个元素的中间节点包含k个子树</td></tr><tr><td>子树中不包含中间节点的元素</td><td>子树中包含中间节点的元素</td></tr><tr><td>叶子节点之间没有链接，范围查询要不断进行中序遍历</td><td>叶子节点为有序链表，方便范围查询</td></tr><tr><td>每个节点都包含数据</td><td>只有叶子节点包含数据</td></tr><tr><td>查询性能最好为1，最差为树高的次数（每次都要IO）</td><td>查询次数为树高，只需要一次IO</td></tr></tbody></table><h3 id="hash索引和b树索引"><a class="markdownIt-Anchor" href="#hash索引和b树索引"></a> Hash索引和B树索引</h3><table><thead><tr><th></th><th>Hash索引</th><th>B树索引</th></tr></thead><tbody><tr><td>等值查询</td><td>更快，但是存在大量hash冲突时会大大降低查询效率</td><td>查询效率比较稳定</td></tr><tr><td>范围查询</td><td>不支持</td><td>支持</td></tr><tr><td>排序</td><td>不支持</td><td>支持</td></tr><tr><td>模糊查询</td><td>不支持</td><td>支持</td></tr><tr><td>前缀查询</td><td>不支持</td><td>支持</td></tr><tr><td>回表查询</td><td>每次查询都要回表</td><td>聚集索引不需要回表</td></tr></tbody></table><h2 id="存储引擎"><a class="markdownIt-Anchor" href="#存储引擎"></a> 存储引擎</h2><h3 id="innodb和myisam"><a class="markdownIt-Anchor" href="#innodb和myisam"></a> InnoDB和MyIsam</h3><table><thead><tr><th></th><th>MyIsam</th><th>Memory</th><th>InnoDB</th></tr></thead><tbody><tr><td>全文索引</td><td>yes</td><td>no</td><td>no</td></tr><tr><td>哈希索引</td><td>no</td><td>yes</td><td>no</td></tr><tr><td>B树索引</td><td>yes</td><td>yes</td><td>yes</td></tr><tr><td>集群索引</td><td>no</td><td>no</td><td>yes</td></tr><tr><td>数据索引</td><td>no</td><td>yes</td><td>yes</td></tr><tr><td>外键</td><td>no</td><td>no</td><td>yes</td></tr><tr><td>锁支持</td><td>表级锁</td><td></td><td>行级锁、表级锁，锁粒度小并发能力更高</td></tr><tr><td>事务</td><td>不支持</td><td></td><td>支持</td></tr><tr><td>外键</td><td>不支持</td><td></td><td>支持</td></tr><tr><td>记录存储顺序</td><td>按记录插入顺序保存</td><td></td><td>按主键大小顺序保存</td></tr><tr><td>存储空间</td><td>MyISAM可被压缩，存储空间较小</td><td></td><td>InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引</td></tr><tr><td>select count(*)</td><td>更快，因为维护了一个计数器</td><td></td><td>通过索引计算</td></tr></tbody></table><h3 id="b树和b树"><a class="markdownIt-Anchor" href="#b树和b树"></a> B树和B+树</h3><table><thead><tr><th>B树</th><th>B+树</th></tr></thead><tbody><tr><td>子树中不包含中间节点的元素</td><td>子树中包含中间节点的元素</td></tr><tr><td></td><td>叶子节点为有序链表，方便范围查询</td></tr><tr><td>每个节点都包含数据</td><td>只有叶子节点包含数据</td></tr><tr><td>查询性能最好为1，最差为树高的次数（每次都要IO）</td><td>查询次数为树高，只需要一次IO</td></tr></tbody></table><h2 id="事务"><a class="markdownIt-Anchor" href="#事务"></a> 事务</h2><h3 id="事务的特性-acid"><a class="markdownIt-Anchor" href="#事务的特性-acid"></a> 事务的特性-ACID</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Atomic（原子性）：事务中的操作，要么都成功，都失败</span><br><span class="line">Consistency（一致性）：数据从一个正确的状态到另一个正确的状态</span><br><span class="line">Isolation（隔离性）：事务之间互相影响，保证同时执行的事务互相之间没有干扰</span><br><span class="line">Durability（持久性）：存到磁盘中，即使机器断电，数据还是有的</span><br></pre></td></tr></table></figure><h3 id="并发事务带来的问题"><a class="markdownIt-Anchor" href="#并发事务带来的问题"></a> 并发事务带来的问题</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**更新丢失:**</span> 两个事务同时更新一行数据，最后一个事务的更新会覆盖掉第一个事务的更新，从而导致第一个事务更新的数据丢失，这是由于没有加锁造成的；</span><br><span class="line"><span class="strong">**脏读:**</span> 事务读取尚未提交的数据;</span><br><span class="line"><span class="strong">**不可重复读:**</span> 更新行导致，在同一事务中，两次读取同一数据，得到内容不同，也就是有其他事务更改了这些数据</span><br><span class="line"><span class="strong">**幻读:**</span> 插入行导致，一个事务在执行过程中读取到了另一个事务已提交的插入数据。</span><br></pre></td></tr></table></figure><h3 id="事务的隔离级别"><a class="markdownIt-Anchor" href="#事务的隔离级别"></a> 事务的隔离级别</h3><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">Read Uncommitted(一个事务可以读取另一个未提交事务的数据)</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">Read Committed(一个事务要等另一个事务提交后才能读取数据)</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">Repeatable Read（默认，在开始读取数据时，不再允许修改操作<br>实现：间隙锁锁住叶子节点的next指针）</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">Serializable(事务串行化顺序执行，效率低下)</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MySql默认的隔离级别：RR</span><br><span class="line">Oracle默认的隔离级别：RC</span><br></pre></td></tr></table></figure><h3 id="mvcc"><a class="markdownIt-Anchor" href="#mvcc"></a> MVCC</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">多版本并发控制（MVCC），解决不可重复读。</span><br><span class="line">为每个数据增加一个版本号，每次修改会对该记录版本号递增，可重复读（RR），读取事务开始前最新的版本号；读已提交（RC，通过间隙锁实现），每次读取最新的数据。</span><br></pre></td></tr></table></figure><h3 id="分布式事务"><a class="markdownIt-Anchor" href="#分布式事务"></a> 分布式事务</h3><p>写的很好的博客：<a href="https://www.cnblogs.com/yaochunhui/p/15594250.html">https://www.cnblogs.com/yaochunhui/p/15594250.html</a></p><h4 id="xa协议"><a class="markdownIt-Anchor" href="#xa协议"></a> XA协议</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">XA分布式事务协议，包含二阶段提交（2PC），三阶段提交（3PC）两种实现。</span><br><span class="line"><span class="strong">**二阶段提交**</span></span><br><span class="line"><span class="code">1.准备阶段</span></span><br><span class="line"><span class="code">  事务协调者，向所有事务参与者发送事务内容，询问是否可以提交事务，并等待参与者回复；</span></span><br><span class="line"><span class="code">  事务参与者收到事务内容，开始执行事务操作，将 undo 和 redo 信息记入事务日志中（但此时并不提交事务）；</span></span><br><span class="line"><span class="code">  如果参与者执行成功，给协调者回复yes,表示可以进行事务提交。如果执行失败，给协调者回复no,表示不可提交。</span></span><br><span class="line"><span class="code">2.提交阶段</span></span><br><span class="line"><span class="code">  如果协调者收到了参与者的失败信息或超时，直接给所有参与者发送回滚（rollback）信息进行事务回滚，否则，发送提交（commit）信息。</span></span><br><span class="line"><span class="code">存在的问题：</span></span><br><span class="line"><span class="code">  性能问题：所有参与者在事务提交阶段处于同步阻塞状态，占用系统资源，容易导致性能瓶颈。</span></span><br><span class="line"><span class="code">可靠性问题：如果协调者存在单点故障问题，如果协调者出现故障，参与者将一直处于锁定状态。</span></span><br><span class="line"><span class="code">数据一致性问题：在阶段2中，如果发生网络问题，一部分事务参与者收到了提交消息，另一部分事务参与者没收到提交消息，那么就导致了节点之间数据的不一致。</span></span><br><span class="line"><span class="code">**三阶段提交**</span></span><br><span class="line"><span class="code">  三阶段提交是在二阶段提交上的改进版本，主要是加入了超时机制。同时在协调者和参与者中都引入超时机制，在等待超时后协调者或参与者会中断事务，避免了协调者单点问题。</span></span><br><span class="line"><span class="code">  1. preCommit</span></span><br><span class="line"><span class="code">     协调者向所有参与者发出包含事务内容的 canCommit 请求，询问是否可以提交事务，并等待所有参与者答复。</span></span><br><span class="line"><span class="code">     参与者收到 canCommit 请求后，如果认为可以执行事务操作，则反馈 yes 并进入预备状态，否则反馈 no。</span></span><br><span class="line"><span class="code">  2. preCommit</span></span><br><span class="line"><span class="code">     阶段1所有参与者均反馈 yes</span></span><br><span class="line"><span class="code">        协调者向所有参与者发出 preCommit 请求，进入准备阶段</span></span><br><span class="line"><span class="code">        参与者收到 preCommit 请求后，执行事务操作，将 undo 和 redo 信息记入事务日志中（但不提交事务）</span></span><br><span class="line"><span class="code">        各参与者向协调者反馈 ack 响应或 no 响应，并等待最终指令</span></span><br><span class="line"><span class="code">     阶段1任何一个参与者反馈 no</span></span><br><span class="line"><span class="code">        协调者向所有参与者发出 abort 请求</span></span><br><span class="line"><span class="code">        无论收到协调者发出的 abort 请求，或者在等待协调者请求过程中出现超时，参与者均会中断事务。</span></span><br><span class="line"><span class="code">  3. do Commit</span></span><br><span class="line"><span class="code">     阶段2所有参与者均反馈 yes</span></span><br><span class="line"><span class="code">        如果协调者处于工作状态，则向所有参与者发出 do Commit 请求</span></span><br><span class="line"><span class="code">        参与者收到 do Commit 请求后，会正式执行事务提交，并释放整个事务期间占用的资源</span></span><br><span class="line"><span class="code">        各参与者向协调者反馈 ack 完成的消息</span></span><br><span class="line"><span class="code">        协调者收到所有参与者反馈的 ack 消息后，即完成事务提交</span></span><br><span class="line"><span class="code">     阶段2任何一个参与者反馈 no</span></span><br><span class="line"><span class="code">        如果协调者处于工作状态，向所有参与者发出 abort 请求</span></span><br><span class="line"><span class="code">        参与者使用阶段1中的 undo 信息执行回滚操作，并释放整个事务期间占用的资源</span></span><br><span class="line"><span class="code">        各参与者向协调者反馈 ack 完成的消息</span></span><br><span class="line"><span class="code">        协调者收到所有参与者反馈的 ack 消息后，即完成事务中断</span></span><br><span class="line"><span class="code">     注意：进入阶段3后，如果参与者超时了还没有收到协调者的信息，会提交事务。</span></span><br><span class="line"><span class="code">  存在的问题：数据不一致问题依然存在，当在参与者收到 preCommit 请求后等待 do commite 指令时，此时如果协调者请求中断事务，而协调者无法与参与者正常通信，会导致参与者继续提交事务，造成数据不一致。</span></span><br></pre></td></tr></table></figure><h4 id="tcc事务"><a class="markdownIt-Anchor" href="#tcc事务"></a> TCC事务</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TCC（Try-Confirm-Cancel）：实现最终一致性。</span><br><span class="line">TCC 是服务化的二阶段编程模型，其Try、Confirm、Cancel个方法均由业务编码实现（可以理解为SQL事务中的Lock、Commit、Rollback）：</span><br><span class="line"><span class="code">Try 操作作为一阶段，负责资源的检查和预留。</span></span><br><span class="line"><span class="code">Confirm 操作作为二阶段提交操作，执行真正的业务。</span></span><br><span class="line"><span class="code">Cancel 是预留资源的取消。</span></span><br><span class="line"><span class="code">Try 阶段是一个初步的操作：</span></span><br><span class="line"><span class="code">完成所有业务检查( 一致性 ) 。</span></span><br><span class="line"><span class="code">预留必须业务资源( 准隔离性 ) 。</span></span><br><span class="line"><span class="code">Try 尝试执行业务。</span></span><br><span class="line"><span class="code">Confirm 阶段：如果事务正常执行，进入Confirm阶段，执行事务提交。</span></span><br><span class="line"><span class="code">Cancel 阶段：如果事务执行异常，进入Cancel阶段，回滚事务，释放资源。</span></span><br></pre></td></tr></table></figure><h4 id="saga事务"><a class="markdownIt-Anchor" href="#saga事务"></a> Saga事务</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Saga 事务也是保证最终一致性。</span><br><span class="line">Saga 事务核心思想是将长事务拆分为多个本地短事务，由 Saga 事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。</span><br><span class="line">Saga 事务基本协议如下：</span><br><span class="line"><span class="code">每个 Saga 事务由一系列幂等的有序子事务(sub-transaction) Ti 组成。</span></span><br><span class="line"><span class="code">每个 Ti 都有对应的幂等补偿动作 Ci，补偿动作用于撤销 Ti 造成的结果。</span></span><br></pre></td></tr></table></figure><h2 id="innodb中的锁"><a class="markdownIt-Anchor" href="#innodb中的锁"></a> InnoDB中的锁</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">行锁（Record lock）：锁住单个行记录</span><br><span class="line">间隙锁（Gap lock）：锁定一个范围，不包括记录本身</span><br><span class="line">范围锁（Next-key lock）：record+gap 锁定一个范围，包含记录本身</span><br><span class="line">注意：innoDB的锁是通过索引来实现的，如果查询条件不是索引，将锁住整张表</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="乐观锁-悲观锁的实现区别使用场景"><a class="markdownIt-Anchor" href="#乐观锁-悲观锁的实现区别使用场景"></a> 乐观锁、悲观锁的实现？区别？使用场景？</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">乐观锁：</span><br><span class="line">  通过 where 条件中的版本号来确定是否更新，版本号递增，当版本号相同时才做修改操作。</span><br><span class="line">悲观锁：</span><br><span class="line">  排他锁：for update</span><br><span class="line">共享锁：in share mode（只能读）</span><br><span class="line">行锁、表锁</span><br><span class="line">  innodb，走索引，能走到行锁</span><br></pre></td></tr></table></figure><h2 id="log"><a class="markdownIt-Anchor" href="#log"></a> log</h2><h3 id="redo-log的作用"><a class="markdownIt-Anchor" href="#redo-log的作用"></a> redo log的作用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是重做日志，提供前滚操作。WAL，write ahead log，随机写变顺序写，提高性能，保证数据的持久性（D）</span><br></pre></td></tr></table></figure><h3 id="undo-log的作用"><a class="markdownIt-Anchor" href="#undo-log的作用"></a> undo log的作用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">回退日志，提供回滚操作。保证原子性（A）（隔离性(I)由锁保证）</span><br></pre></td></tr></table></figure><h3 id="binlog的作用"><a class="markdownIt-Anchor" href="#binlog的作用"></a> binlog的作用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">备份、主备同步。binlog是一个二进制格式的文件，用于记录用户对数据库更新的SQL语句信息。</span><br></pre></td></tr></table></figure><h3 id="innodb和myisam的区别"><a class="markdownIt-Anchor" href="#innodb和myisam的区别"></a> InnoDB和MyIsam的区别？</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">InnoDB（默认，公司用的都是这个）</span><br><span class="line">  1、支持事务处理、ACID事务特性；</span><br><span class="line">  2、实现了SQL标准的四种隔离级别；</span><br><span class="line">  3、支持行级锁和外键约束；</span><br><span class="line">  4、锁级别为行锁，行锁优点是适用于高并发的频繁表修改，高并发是性能优于 MyISAM。缺点是系统消耗较大。</span><br><span class="line">  5、索引存储数据（聚集索引），相比 MyISAM 需要更大的内存。</span><br><span class="line">MyIsam</span><br><span class="line">  1.高性能读取；</span><br><span class="line">  2.因为它保存了表的行数，当使用COUNT统计时不会扫描全表</span><br><span class="line">  3.支持全文本索引（更好的选择是EleasticSearch）</span><br></pre></td></tr></table></figure><h2 id="数据库设计的三大范式"><a class="markdownIt-Anchor" href="#数据库设计的三大范式"></a> 数据库设计的三大范式</h2><pre class="highlight"><code class="markdown">（1）每个属性都是原子的（必须遵循的，方便查）（2）表中每个列都和主键相关(也是要遵循的)，不能部分相关（3）表中的每列和主键直接相关，不能间接相关</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;整理一些mysql的知识。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Mysql" scheme="https://eoccc.gitee.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="https://eoccc.gitee.io/2022/10/02/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>https://eoccc.gitee.io/2022/10/02/%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2022-10-02T07:25:19.000Z</published>
    <updated>2022-10-06T14:24:35.421Z</updated>
    
    <content type="html"><![CDATA[<p>红黑树是特殊的AVL树(二叉平衡树)，设计红黑树的目的，就是解决平衡树的维护起来比较麻烦的问题，红黑树读取略逊于AVL，维护强于AVL，每次插入和删除的平均旋转次数应该是远小于平衡树。</p><span id="more"></span><h1 id="红黑树的应用"><a class="markdownIt-Anchor" href="#红黑树的应用"></a> 红黑树的应用</h1><ol><li>IO多路复用的实现采用红黑树组织管理，以支持快速的增删改查</li><li>ngnix中用红黑树管理timer，因为红黑树是有序的，可以很快的得到距离当前最小的定时器</li><li>java中TreeMap，jdk1.8的hashMap实现</li></ol><h1 id="红黑树的特征"><a class="markdownIt-Anchor" href="#红黑树的特征"></a> 红黑树的特征</h1><p><strong>红定理：</strong> 不会有连续的红色节点，红色节点的子节点必定为黑色。</p><p><strong>黑定理：</strong> 根节点必须是黑节点，所有叶子节点都是黑色。</p><blockquote><ol><li>每个节点要么是黑色，要么是红色</li><li>根节点是黑色</li><li>每个叶子节点（NIL）是黑色</li><li>每个红色结点的两个子结点一定都是黑色</li><li>任意一节点到每个叶子结点的路径都包含数量相同的黑结点</li></ol></blockquote><h1 id="红黑树的插入"><a class="markdownIt-Anchor" href="#红黑树的插入"></a> 红黑树的插入</h1><p>基本操作是添加、删除和旋转。在对红黑树进行添加或删除后，会用到旋转方法。旋转的目的是让树保持红黑树的特性。旋转包括两种：左旋 和 右旋</p><h2 id="左旋"><a class="markdownIt-Anchor" href="#左旋"></a> 左旋</h2><p>父节点（P）左沉，右节点的的左节点（R）变成父节点的右子节点，右节点（V）变成新的父节点。</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1h6vhnbkg17j30ta094jrp.jpg" alt="image-20221006123731381" style="zoom:50%;"><h2 id="右旋"><a class="markdownIt-Anchor" href="#右旋"></a> 右旋</h2><p>父节点（P）右沉，左节点的的右节点（K）变成父节点的左子节点，左节点（F）变成新的父节点。</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1h6vhniugauj30xg094q3a.jpg" alt="image-20221006124133170" style="zoom:50%;"><h2 id="插入节点"><a class="markdownIt-Anchor" href="#插入节点"></a> 插入节点</h2><p>插入红色节点，不需要做自平衡</p><p>插入黑色节点，需要做自平衡</p><h3 id="插入红色节点"><a class="markdownIt-Anchor" href="#插入红色节点"></a> 插入红色节点</h3><p><strong>叔叔节点存在且为红色</strong></p><p>将父节点和叔叔节点变成黑色，将主父节点变成红色（主父节点违反了红黑树的规则，要继续做变色处理，最后如果根节点变成了红色，要做自旋）。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1h6vhnm2i70j30k60963zb.jpg" alt="image-20221006125541140" style="zoom:50%;">   <img src="https://tva1.sinaimg.cn/large/006y8mN6ly1h6vhnplw2cj30kc090t9i.jpg" alt="image-20221006130117125" style="zoom:50%;"></p><p><strong>叔叔节点不存在或为黑色</strong></p><ol><li><p>插入节点的父节点为左节点</p><ul><li><p>插入节点为左节点</p><p>右旋</p></li></ul><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1h6vhntajkcj30ki09474y.jpg" alt="image-20221006130459279" style="zoom:50%;"><ul><li><p>插入节点为右节点</p><p>先左旋，再右旋</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1h6vhnuqyepj30xc0a8dh4.jpg" alt="image-20221006130658504" style="zoom:45%;"></li></ul></li><li><p>插入节点的父节点为右节点</p><ul><li><p>插入节点为左节点</p><p>先右旋，再左旋</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1h6vhnwxpx4j30xc0as75p.jpg" alt="image-20221006130906594" style="zoom:45%;"></li><li><p>插入节点为右节点</p><p>左旋</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1h6vho0a6tnj30t60e2ta4.jpg" alt="image-20221006130925077" style="zoom:40%;"></li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;红黑树是特殊的AVL树(二叉平衡树)，设计红黑树的目的，就是解决平衡树的维护起来比较麻烦的问题，红黑树读取略逊于AVL，维护强于AVL，每次插入和删除的平均旋转次数应该是远小于平衡树。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据结构" scheme="https://eoccc.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-ShardingSphere分库分表</title>
    <link href="https://eoccc.gitee.io/2022/09/27/Mysql-ShardingSphere%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    <id>https://eoccc.gitee.io/2022/09/27/Mysql-ShardingSphere%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</id>
    <published>2022-09-27T08:25:19.000Z</published>
    <updated>2022-10-08T05:57:28.052Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://shardingsphere.apache.org/document/current/cn/overview/#shardingsphere-jdbc">Apache ShardingSphere</a>是一款开源的分布式数据库中间件组成的生态圈。它由Sharding-JDBC、Sharding-Proxy和Sharding-Sidecar（规划中）组成。提供标准化的数据分片、分布式事务和数据库治理功能，可适用于如Java同构、异构语言、容器、云原生等各种多样化的应用场景。</p><span id="more"></span><p>Inline 不支持范围查找</p><p>Standard 支持范围查找</p><p>Complex  支持范围查找、支持多分片键</p><p>Hint 通过Hint指定分片值而非从SQL中提取分片值的方式进行分片</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://shardingsphere.apache.org/document/current/cn/overview/#shardingsphere-jdbc&quot;&gt;Apache ShardingSphere&lt;/a&gt;是一款开源的分布式数据库中间件组成的生态圈。它由Sharding-JDBC、Sharding-Proxy和Sharding-Sidecar（规划中）组成。提供标准化的数据分片、分布式事务和数据库治理功能，可适用于如Java同构、异构语言、容器、云原生等各种多样化的应用场景。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Mysql" scheme="https://eoccc.gitee.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-分库分表</title>
    <link href="https://eoccc.gitee.io/2022/09/26/Mysql-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    <id>https://eoccc.gitee.io/2022/09/26/Mysql-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</id>
    <published>2022-09-26T08:25:19.000Z</published>
    <updated>2023-03-15T02:04:36.529Z</updated>
    
    <content type="html"><![CDATA[<p>不管是IO瓶颈，还是CPU瓶颈，最终都会导致数据库的活跃连接数增加，进而逼近甚至达到数据库可承载活跃连接数的阈值。在业务Service来看就是，可用数据库连接少甚至无连接可用。</p><span id="more"></span><h1 id="数据库瓶颈"><a class="markdownIt-Anchor" href="#数据库瓶颈"></a> 数据库瓶颈</h1><p>数据量增长过快或者业务规模扩大导致单个数据库实例无法满足系统的性能和容量需求，需要通过分布式扩展来解决这些问题。</p><p>具体来说，以下情况可能需要进行分库分表：</p><ol><li>数据量过大：当单个数据库实例存储的数据量达到了数据库系统的承载极限，无法再继续扩展时，需要进行分库分表来分散存储数据的压力。</li><li>数据访问频繁度不同：某些数据表可能会被频繁访问，而其他表则很少被访问，此时可以通过分表将热点数据和冷数据分开存储，从而提高数据库的性能。</li><li>数据访问模式不同：当数据表中的数据被不同的业务模块访问时，可能需要将这些数据分散到不同的数据库中，以提高系统的性能。</li><li>业务扩展需要：当业务规模扩大时，可能需要通过分库分表来增加数据库的并发能力和容量，以满足业务需求。</li><li>分布式部署需要：当系统需要进行分布式部署时，可能需要将数据库进行分库分表来支持分布式部署架构。</li></ol><p>需要注意的是，在进行数据库分库时，需要考虑数据的一致性和分布式事务的处理。此外，需要根据具体的业务场景和数据特点选择最合适的分库方式。</p><h2 id="io瓶颈"><a class="markdownIt-Anchor" href="#io瓶颈"></a> IO瓶颈</h2><ol><li><p>磁盘IO瓶颈</p><p>热点数据太多，mysql的缓存放不下，产生大量的回表查询，导致查询数据降低。</p><p>解决：分库，垂直分表</p></li><li><p>网络IO瓶颈</p><p>请求的数据太多，带宽不够</p><p>解决：分库分集群</p></li></ol><h2 id="cpu瓶颈"><a class="markdownIt-Anchor" href="#cpu瓶颈"></a> CPU瓶颈</h2><ol><li><p>SQL问题</p><p>如SQL中包含join，group by，order by，非索引字段条件查询等，增加CPU运算的操作</p><p>解决：SQL优化，建立合适的索引，在业务Service层进行业务计算</p></li><li><p>单表数据量太大</p><p>查询时扫描的行数太多，sql效率低</p><p>解决：水平分表</p></li></ol><h1 id="分库"><a class="markdownIt-Anchor" href="#分库"></a> 分库</h1><h2 id="水平分库horizontal-sharding"><a class="markdownIt-Anchor" href="#水平分库horizontal-sharding"></a> 水平分库（Horizontal Sharding）</h2><p>水平分库是指按照数据行的关系将数据拆分到不同的数据库中。例如，可以将用户表按照用户ID的范围进行拆分，将不同范围的用户存储在不同的数据库中。</p><p>根据分库键，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。</p><ul><li>每个库中的表结构都是一样的</li><li>每个库中的数据都不一样，没有交集</li><li>所有库中的数据的并集为全量数据</li></ul><p>适用场景：一个库的数据量太大，导致cpu、磁盘io、网络io的压力都很高。</p><p><img src="https://gitee.com/eoccc/pic-shack/raw/master/-wKcOJIPb.jpeg" alt="-wKcOJIPb.jpeg"></p><h2 id="垂直分库vertical-sharding"><a class="markdownIt-Anchor" href="#垂直分库vertical-sharding"></a> 垂直分库（Vertical Sharding）</h2><p>垂直分库是指按照数据表或列的关系将数据拆分到不同的数据库中。例如，可以将订单表和用户表分别存储在不同的数据库中，这样可以避免数据表之间的冗余和重复。</p><p>以表或列为依据，按照业务归属不同，将不同的表拆分到不同的库中。</p><ul><li>每个库中存放不同的表</li><li>每个库中的数据都不同</li><li>所有库中的数据的并集为全部数据</li></ul><p>适用场景：数据库中的表越来越多，导致数据库连接数不足。业务发展到这种情况，可以考虑拆分服务。</p><p><img src="https://gitee.com/eoccc/pic-shack/raw/master/99Watzd9D.jpeg" alt="99Watzd9D.jpeg"></p><h2 id="分片sharding"><a class="markdownIt-Anchor" href="#分片sharding"></a> 分片（Sharding）</h2><p>分片是指将数据按照某种规则进行分割，并将不同的分片存储在不同的数据库中。例如，可以按照用户的地理位置将用户数据分割成不同的分片，并将每个分片存储在不同的数据库中。</p><p>和水平分库相似。</p><h2 id="混合分库hybrid-sharding"><a class="markdownIt-Anchor" href="#混合分库hybrid-sharding"></a> 混合分库（Hybrid Sharding）</h2><p>混合分库是指将垂直分库和水平分库结合起来，以实现更精细的数据划分。例如，可以将用户表按照用户ID的范围进行水平分割，并将不同的用户表存储在不同的数据库中，同时将订单表和商品表等其他表垂直分割到不同的数据库中。</p><h1 id="分表"><a class="markdownIt-Anchor" href="#分表"></a> 分表</h1><h2 id="水平分表"><a class="markdownIt-Anchor" href="#水平分表"></a> 水平分表</h2><p>根据分表键，按照一定策略（hash、range等），将一个库中的数据拆分到多个表中。</p><ul><li>每个表中的表结构都是一样的</li><li>每个表中的数据都不一样，没有交集</li><li>所有表中的数据的并集为全量数据</li></ul><p>适用场景：单表的数据量太大，导致查询效率降低。</p><p><img src="https://gitee.com/eoccc/pic-shack/raw/master/VNwsPuzzM.jpeg" alt="VNwsPuzzM.jpeg"></p><p>一些水平分表的方式：</p><ol><li>按照数据量分表：按照数据量的大小将数据分散存储到不同的表中，每个表存储一定量的数据。这种方式比较简单，但需要预估数据增长量并及时进行迁移，否则可能会导致某些表数据过大而影响系统性能。</li><li>按照数据业务属性分表：将数据按照业务属性进行分表，例如将订单表按照用户ID分表，将商品表按照商品类别分表等。这种方式可以提高查询效率，但需要对业务进行分析，合理设计分表规则。</li><li>按照数据地理位置分表：将数据按照地理位置进行分表，例如将用户按照所在省份进行分表。这种方式适用于需要根据地理位置进行查询的业务，可以减少跨节点查询的开销。</li><li>按照时间分表：将数据按照时间进行分表，例如将日志表按照日期分表，每天一个表。这种方式可以提高查询效率，同时方便数据的归档和清理。</li></ol><h2 id="垂直分表"><a class="markdownIt-Anchor" href="#垂直分表"></a> 垂直分表</h2><p>以字段为依据，按照字段的活跃度，将表中字段拆到不同的表（主表和扩展表）中。</p><ul><li>每个表的结构不一样</li><li>每个表中只有一个关联键是一样的，其他数据都不一样</li><li>所有表的所有列的并集为全量数据</li></ul><p>适用场景：单表的字段过多，同时存在热数据和冷数据，单行数据占用的空间大，导致叶缓存能够保存的数据条数减少，查询时产生大量IO。另外，字段过多，查询条件也会很多，就需要建立更多的索引，导致插入、更新和删除效率降低，索引文件很大。</p><p><img src="https://gitee.com/eoccc/pic-shack/raw/master/a_YCOhAzj.jpeg" alt="a_YCOhAzj.jpeg"></p><p>需要注意：分表以后，进行联合查询的时候要尽量不要使用join，因为join不仅会增加CPU负担并且会讲两个表耦合在一起（必须在一个数据库实例上）。关联数据，应该在业务Service层做文章，分别获取主表和扩展表数据然后用关联字段关联得到全部数据。</p><h2 id="组合分库分表"><a class="markdownIt-Anchor" href="#组合分库分表"></a> 组合分库分表</h2><p>在一些场景下，只有分库或者分表是不能解决问题的。这时我们可以结合分库和分表，灵活进行配。</p><p>我们可以先根据第一个key进行分库，然后根据第二个key进行分表。</p><p>并且可以根据不同的业务情况，设定不同的分配策略，比如订单表，对于订单较多的月份，我们可以分配更多的表，使用hash策略将订单均匀的写到不同的表中。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;不管是IO瓶颈，还是CPU瓶颈，最终都会导致数据库的活跃连接数增加，进而逼近甚至达到数据库可承载活跃连接数的阈值。在业务Service来看就是，可用数据库连接少甚至无连接可用。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Mysql" scheme="https://eoccc.gitee.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Lombok @Builder注解导致默认值失效</title>
    <link href="https://eoccc.gitee.io/2022/09/11/Lombok%20@Builder%E6%B3%A8%E8%A7%A3%E5%AF%BC%E8%87%B4%E9%BB%98%E8%AE%A4%E5%80%BC%E5%A4%B1%E6%95%88/"/>
    <id>https://eoccc.gitee.io/2022/09/11/Lombok%20@Builder%E6%B3%A8%E8%A7%A3%E5%AF%BC%E8%87%B4%E9%BB%98%E8%AE%A4%E5%80%BC%E5%A4%B1%E6%95%88/</id>
    <published>2022-09-11T07:25:19.000Z</published>
    <updated>2022-09-22T12:03:10.125Z</updated>
    
    <content type="html"><![CDATA[<p>Lombok @Builder注解可以让我们很方便的使用builder模式构建对象，但是今天发现使用@Builder注解创建对象时，不会初始化默认值。</p><p>我们测试一下，先写个demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;haha&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试一下</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> User.builder().build();</span><br><span class="line">  System.out.println(user.getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：null</span></span><br></pre></td></tr></table></figure><p>编译以后，会生成两个class文件，一个是User自己的class，另一个是builder生成的class：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User$UserBuilder.class</span><br><span class="line">User.class</span><br></pre></td></tr></table></figure><p>随后我们反编译一下 看看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javap -p User.class</span><br><span class="line">javap -p User\<span class="variable">$UserBuilder</span>.class</span><br></pre></td></tr></table></figure><p>反编译结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="comment">//属性上设置了默认值</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;haha&quot;</span>;</span><br><span class="line"></span><br><span class="line">  User(<span class="keyword">final</span> String name) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> UserBuilder <span class="title function_">builder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserBuilder</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    UserBuilder() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//执行build的时候，没有将默认值设置进去</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;User.UserBuilder(name=&quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>通过反编译的结果，我们可以看出编译后的代码是没有给User设置默认值的。</strong></p><p>在1.6.X版本中，Lombok加入了@Builder.Default注解，以实现默认值的初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Builder</span>.Default</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;haha&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> User.builder().build();</span><br><span class="line">  System.out.println(user.getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：haha</span></span><br></pre></td></tr></table></figure><p>反编译看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//User.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//默认值放到了这个方法里面</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String $<span class="keyword">default</span>$name() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;haha&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  User(<span class="keyword">final</span> String name) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> UserBuilder <span class="title function_">builder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserBuilder</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> name$set;</span><br><span class="line">    <span class="keyword">private</span> String name$value;</span><br><span class="line"></span><br><span class="line">    UserBuilder() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> UserBuilder <span class="title function_">name</span><span class="params">(<span class="keyword">final</span> String name)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name$value = name;</span><br><span class="line">      <span class="built_in">this</span>.name$set = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">name$value</span> <span class="operator">=</span> <span class="built_in">this</span>.name$value;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.name$set) &#123;</span><br><span class="line"><span class="comment">//执行build方法的时候，如果name没有设置，调用设置默认值</span></span><br><span class="line">        name$value = User.$<span class="keyword">default</span>$name();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(name$value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;User.UserBuilder(name$value=&quot;</span> + <span class="built_in">this</span>.name$value + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所以使用Lombok的<code>@Builder</code>注解默认是不会初始化默认值的，如果需要使用默认值，需要将版本升级到1.6.x，并使用<code>@Builder.Default</code>注解标记有默认值的属性。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Lombok @Builder注解可以让我们很方便的使用builder模式构建对象，但是今天发现使用@Builder注解创建对象时，不会初始化默认值。&lt;/p&gt;
&lt;p&gt;我们测试一下，先写个demo：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;ta</summary>
      
    
    
    
    
    <category term="随笔" scheme="https://eoccc.gitee.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="踩坑" scheme="https://eoccc.gitee.io/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>DDD大杂烩</title>
    <link href="https://eoccc.gitee.io/2022/08/21/DDD%E5%A4%A7%E6%9D%82%E7%83%A9/"/>
    <id>https://eoccc.gitee.io/2022/08/21/DDD%E5%A4%A7%E6%9D%82%E7%83%A9/</id>
    <published>2022-08-21T07:25:19.000Z</published>
    <updated>2022-10-06T04:25:27.255Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些DDD的知识，比较碎。</p><span id="more"></span><h1 id="设计的两个阶段"><a class="markdownIt-Anchor" href="#设计的两个阶段"></a> 设计的两个阶段</h1><p>领域驱动设计一般分为两个阶段：</p><blockquote><ol><li>以一种领域专家、设计人员、开发人员都能理解的“通用语言”作为相互交流的工具，在不断交流的过程中发现和挖出一些主要的领域概念，然后将这些概念设计成一个领域模型；</li><li>由领域模型驱动软件设计，用代码来表现该领域模型。领域需求的最初细节，在功能层面通过领域专家的讨论得出。</li></ol></blockquote><h1 id="领域模型"><a class="markdownIt-Anchor" href="#领域模型"></a> 领域模型</h1><p>领域模型具有以下特点：</p><blockquote><ol><li>领域模型是对具有某个边界的领域的一个抽象，反映了领域内用户业务需求的本质；领域模型是有边界的，只反应了我们在领域内所关注的部分；</li><li>领域模型只反映业务，和任何技术实现无关；领域模型不仅能反映领域中的一些实体概念，如货物，书本，应聘记录，地址，等；还能反映领域中的一些过程概念，如资金转账，等；</li><li>领域模型确保了我们的软件的业务逻辑都在一个模型中，都在一个地方；这样对提高软件的可维护性，业务可理解性以及可重用性方面都有很好的帮助；</li><li>领域模型能够帮助开发人员相对平滑地将领域知识转化为软件构造；</li><li>领域模型贯穿软件分析、设计，以及开发的整个过程；领域专家、设计人员、开发人员通过领域模型进行交流，彼此共享知识与信息；因为大家面向的都是同一个模型，所以可以防止需求走样，可以让软件设计开发人员做出来的软件真正满足需求；</li><li>要建立正确的领域模型并不简单，需要领域专家、设计、开发人员积极沟通共同努力，然后才能使大家对领域的认识不断深入，从而不断细化和完善领域模型；</li><li>为了让领域模型看的见，我们需要用一些方法来表示它；图是表达领域模型最常用的方式，但不是唯一的表达方式，代码或文字描述也能表达领域模型；</li><li>领域模型是整个软件的核心，是软件中最有价值和最具竞争力的部分；设计足够精良且符合业务需求的领域模型能够更快速的响应需求变化；</li></ol></blockquote><h1 id="一些基本概念"><a class="markdownIt-Anchor" href="#一些基本概念"></a> 一些基本概念</h1><h2 id="实体"><a class="markdownIt-Anchor" href="#实体"></a> 实体</h2><p>实体（Entity）通常具备唯一id，能够被持久化，具有业务逻辑，对应现实世界业务对象。不要理解成简单的orm的对象。</p><h2 id="值对象"><a class="markdownIt-Anchor" href="#值对象"></a> 值对象</h2><p>值对象（value object）描述事物的对象，可以用来传递参数或对实体进行补充，可以认为是实体的属性，没有唯一id。</p><p>如果值对象是共享的，那么这个值对象的所有属性都应该只读。</p><p>值对象的属性应该尽可能简单，不要引用很多其他对象。</p><h2 id="聚合及聚合根"><a class="markdownIt-Anchor" href="#聚合及聚合根"></a> 聚合及聚合根</h2><p>聚合（aggregation）是用来定义领域边界的领域模式，通过定义清晰的对象所属关系和边界来实现领域的内聚，避免错综复杂的关系网。</p><p>一个聚合是一组对象组成的关系整体，每个聚合都有一个根对象，即聚合根（aggregation root），外部只能通过聚合根访问内部的聚合。</p><p>聚合的划分会直接映射到程序的结构上，DDD推荐按聚合设计子包，每个聚合对应一个子包，内部包括entity、value object、repository、domain等。</p><p>聚合的特点：</p><blockquote><ol><li>每个聚合有一个根和一个边界，边界定义了一个聚合内部有哪些实体或值对象，聚合根是聚合内的某个实体；</li><li>聚合内部的对象之间可以相互引用，但是聚合外部如果要访问聚合内部的对象时，必须通过聚合根访问聚合内的对象，也就是说聚合根是外部可以保持对它的引用的唯一元素；</li><li>聚合内除根以外的其他实体的唯一标识都是本地标识，也就是只要在聚合内部保持唯一即可；</li><li>聚合根负责与外部其他对象打交道并维护自己内部的业务规则；</li><li>聚合内部的对象可以持有其他聚合根的引用；</li><li>删除一个聚合根时必须同时删除该聚合内的所有相关对象。</li></ol></blockquote><h2 id="工厂"><a class="markdownIt-Anchor" href="#工厂"></a> 工厂</h2><p>工厂（Factory）用来封装创建一个复杂对象尤其是聚合时所需的逻辑，作用是将创建对象的细节隐藏起来。客户传递给工厂一些简单的参数，然后工厂可以在内部创建出一个复杂的领域对象然后返回给客户。当创建<strong>复杂的</strong>实体或值对象时建议使用工厂模式。</p><p>一个良好的工厂应该具有以下特点：</p><blockquote><ol><li>每个创建方法都是原子的；</li><li>一个工厂应该只能生产透明状态的对象；</li><li>创建整个实体时满足所有的变量；</li><li>一个工厂创建聚合根，聚合内部的实体通过聚合根调用其他工厂创建。</li></ol></blockquote><p>工厂会与其参数产生耦合，对于参数的选择，来自较低设计层的参数会更加安全。</p><p>工厂应该处理创建过程中的所有异常，可以定义一定的标准，比如发生异常的时候返回null，或者抛出指定的异常以通知使用者。</p><p>可以将固定规则的检查工作委托给工厂，而且这通常是最佳的。</p><h2 id="仓储"><a class="markdownIt-Anchor" href="#仓储"></a> 仓储</h2><p>仓储（Repositories）是用来存储实体的集合。仓储中存储的一定是聚合。</p><p>repository面向的是聚合根，dao面向的是数据访问，dao的方法是细粒度的。客户端应该始终调用领域对象，领域对象再调用dao实现数据库交互。</p><h2 id="服务"><a class="markdownIt-Anchor" href="#服务"></a> 服务</h2><p>服务（Service）只负责协调并委派业务逻辑给领域对象进行处理，其本身并不真正实现业务逻辑，绝大部分的业务逻辑都由领域对象承载和实现。</p><p>Service可与多种组件进行交互，包括：其他的service、领域对象和repository 或 dao。</p><p>服务接口的入参和出参都应该是dto。</p><h2 id="dto"><a class="markdownIt-Anchor" href="#dto"></a> DTO</h2><p>数据传输对象（Data Transfer Object）可以起到隐藏领域细节，帮助实现独立封闭的领域模型的作用。</p><p>DTO与领域对象之间的转换通常由Assembler承担。</p><h2 id="interface"><a class="markdownIt-Anchor" href="#interface"></a> Interface</h2><p>Interface层包含与其他系统/客户进行交互的接口与通信设施，在多数应用里，该层可能提供包括web service、rmi或rest等在内的一种或多种通信接口。该层主要由facade、dto和assembler三类组件构成，三类组件均是典型的j2ee模式。</p><h2 id="application"><a class="markdownIt-Anchor" href="#application"></a> Application</h2><p>Application层中主要组件是service。只负责协调并委派业务逻辑给领域对象进行处理。</p><h2 id="domain"><a class="markdownIt-Anchor" href="#domain"></a> Domain</h2><p>Domain层是整个系统的核心层，该层维护一个使用面向对象技术实现的领域模型，几乎全部的业务逻辑会在该层实现。Domain层包含entity（实体）、value object(值对象)、domain event（领域事件）和repository（仓储）等多种重要的领域组件。</p><h2 id="infrastructure"><a class="markdownIt-Anchor" href="#infrastructure"></a> Infrastructure</h2><p>Infrastructure（基础设施层）为interfaces、application和domain三层提供支撑。所有与具体平台、框架相关的实现会在infrastructure中提供，避免三层特别是domain层掺杂进这些实现，从而“污染”领域模型。Infrastructure中最常见的一类设施是对象持久化的具体实现。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一些DDD的知识，比较碎。&lt;/p&gt;</summary>
    
    
    
    
    <category term="DDD" scheme="https://eoccc.gitee.io/tags/DDD/"/>
    
    <category term="随笔" scheme="https://eoccc.gitee.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>时间轮</title>
    <link href="https://eoccc.gitee.io/2022/08/10/%E6%97%B6%E9%97%B4%E8%BD%AE/"/>
    <id>https://eoccc.gitee.io/2022/08/10/%E6%97%B6%E9%97%B4%E8%BD%AE/</id>
    <published>2022-08-10T14:52:41.000Z</published>
    <updated>2022-08-21T13:19:47.693Z</updated>
    
    <content type="html"><![CDATA[<p>JDK中Timer和DelayQueue可以实现定时任务和延时操作的功能，但是O(nlogn)的时间复杂度在高并发的时候存在性能瓶颈，因此Kafka、Netty、ZooKeeper、Quartz等组件都使用了时间轮作为定时器。</p><span id="more"></span><h1 id="单层时间轮"><a class="markdownIt-Anchor" href="#单层时间轮"></a> 单层时间轮</h1><h2 id="时间轮的概念"><a class="markdownIt-Anchor" href="#时间轮的概念"></a> 时间轮的概念</h2><p>时间轮( TimingWheel) 是一个存储定时任务的环形队列，底层采用数组实现，数组中的每个元素可以存放一个定时任务列表( TimerTaskList)。 TimerTaskList 是一个环形的双向链表，链表中的元素即为定时任务( TimerTaskEntry)，其中封装了真正的定时任务 (TimerTask) 。</p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5dde2pmc6j20mc0cwq3s.jpg" alt="image-20220820161912938" style="zoom:60%;"><p>时间轮的特征：</p><blockquote><ol><li>时间轮由多个时间格组成，时间格的个数固定为wheelSize</li><li>每个时间格的时间跨度为tickMs</li><li>总的时间跨度interval即为 tickMs * wheelSize</li><li>时间轮当前所处的时间为currentTime，currentTime是tickMs的整数倍</li></ol></blockquote><h2 id="插入任务"><a class="markdownIt-Anchor" href="#插入任务"></a> 插入任务</h2><p>当前时间为currentTime，要插入一个延时时间为delayTime的任务时，会将这个任务插入到当前时间格+(delayTime/tickMs)格中。</p><p>假设时间轮的tickMs为1ms，wheelSize为20。初始时currentTime指向时间格0，此时要插入一个定时为2ms，则会将这个任务插入到时间格2中。</p><p>当时间过了2ms后，currentTime指向了时间格2，需要将时间格2对应的TimTaskList中的任务执行。</p><p>此时又有一个定时为8的任务需要插入，则会插入到时间格10。</p><p>如果此时又要插入一个定时为19ms的任务，则会插入到时间格1。</p><p>但是需要注意，这个<strong>时间轮的interval时间为20ms，即插入的任务的定时不能超过20ms。</strong></p><h2 id="执行任务"><a class="markdownIt-Anchor" href="#执行任务"></a> 执行任务</h2><p>currentTime 可以将整个时间轮划分 为到期部分和未到期部分， currentTime 当前指向的时间格也属于到期部分，表示刚好到期，需 要处理此时间格所对应的 TimerTaskList 中的所有任务。</p><h1 id="多层时间轮"><a class="markdownIt-Anchor" href="#多层时间轮"></a> 多层时间轮</h1><p>当一层时间轮的interval时间不够用时，我们就需要升级到多层时间轮。多层时间轮之间的wheelSize是相同的，下一层时间轮的tickMs是上一层时间轮的interval：</p><blockquote><p>假设第一层的时间轮为：tickMs=1ms、wheelSize=20、inteval=20ms</p><p>则第二层的时间轮为：tickMs=20ms、wheelSize=20、inteval=400ms</p></blockquote><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5dddyenmtj20nw0ni760.jpg" alt="image-20220820171558184" style="zoom:50%;"><h2 id="插入任务-2"><a class="markdownIt-Anchor" href="#插入任务-2"></a> 插入任务</h2><p>当一层时间轮的interval不足以容纳一个任务的定时时，就会升级到下一层时间轮。</p><p>在前面的时间轮中，如果我们要插入一个定时为350ms的任务时，第一层时间轮不足以容纳，就会升级到第二层时间轮，最终放到时间格17中（350/40=17）。</p><p>由于最低层的时间轮的tickMs=1，则这个时间轮的精度为1ms。</p><h2 id="执行任务-2"><a class="markdownIt-Anchor" href="#执行任务-2"></a> 执行任务</h2><p>随着时间的流逝，第二层的的currentTiume指向了第17格，即时间走了340ms，对于之前插入的定时为350ms的任务，还剩余10ms，这时还不能执行这个任务。</p><p>此时，会将这个任务从第二层时间轮中取出，然后重新插入一个定时为10ms的任务，最终插入到第一层的时间格10，当currentTime指向第一层的时间格时，才会真正执行这个任务，并将这个任务从时间轮中删除。</p><p>但是如果我们在currentTime=0时，插入了一个定时为200ms的任务，最终插入到了第二层的时间格5，currentTime指向这个时间格的时候，这个任务剩余的时间为0，所以会直接执行，不需要重新插入时间轮。</p><p>另外，在判断一个任务能不能执行的时候，还需要判断时间轮的精度，如果剩余的时间小于时间轮的精度，则会直接执行，否则需要重新插入到时间轮。</p>]]></content>
    
    
    <summary type="html">定时任务、延时操作的定时器实现。</summary>
    
    
    
    
    <category term="技术笔记" scheme="https://eoccc.gitee.io/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>protobuf序列化和反序列化</title>
    <link href="https://eoccc.gitee.io/2022/08/10/protobuf%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://eoccc.gitee.io/2022/08/10/protobuf%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2022-08-10T10:25:19.000Z</published>
    <updated>2022-08-16T01:55:47.894Z</updated>
    
    <content type="html"><![CDATA[<p>Protobuf是一个很优秀的序列化和反序列化工具，具有较高的效率，并且使用紧凑的二进制码，能够减小内存占用，但是有一些坑，需要我们能够正确的使用。这篇博客就来记录一些Protobuf的使用和一些踩过的坑。</p><span id="more"></span><p>使用protobuf序列化和反序列化时，需要注意：</p><blockquote><ol><li>不支持Map类型，可以包装成其他类型再进行序列化</li><li>添加新字段的时候必须添加到尾部</li><li>不能修改名字</li><li>不能修改类型</li><li>不能删除字段</li></ol></blockquote><p>protobuf使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ProtoStuffSerializer</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(ProtoStuffSerializer.class);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span>[] EMPTY_BYTES = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Field sizeField;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">      sizeField = WriteSession.class.getDeclaredField(<span class="string">&quot;size&quot;</span>);</span><br><span class="line">      sizeField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 序列化成字节数组</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] serialize(Object obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> EMPTY_BYTES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">byte</span>[] bytes;</span><br><span class="line">      Schema&lt;Object&gt; schema = (Schema&lt;Object&gt;) getSchema(obj.getClass());</span><br><span class="line">      <span class="type">LinkedBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> LinkedBuffer.allocate(<span class="number">4096</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        bytes = ProtobufIOUtil.toByteArray(obj, schema, buffer);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        buffer.clear();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      logger.error(<span class="string">&quot;protostuff serialize error:&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EMPTY_BYTES;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] serialize(Object obj, <span class="type">byte</span>[] preFix) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> EMPTY_BYTES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">Schema</span> <span class="variable">schema</span> <span class="operator">=</span> getSchema(obj.getClass());</span><br><span class="line">      <span class="type">byte</span>[] init = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8192</span>];</span><br><span class="line">      System.arraycopy(preFix, <span class="number">0</span>, init, <span class="number">0</span>, preFix.length);</span><br><span class="line">      <span class="type">LinkedBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> LinkedBuffer.wrap(init, <span class="number">0</span>, preFix.length);</span><br><span class="line">      <span class="keyword">final</span> <span class="type">ProtostuffOutput</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProtostuffOutput</span>(buffer);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        schema.writeTo(output, obj);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotSupportSerialException</span>(<span class="string">&quot;Serializing to a byte array threw an IOException &quot;</span> +</span><br><span class="line">                                            <span class="string">&quot;(should never happen).&quot;</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">      sizeField.set(output, output.getSize() + <span class="number">4</span>);</span><br><span class="line">      <span class="keyword">return</span> output.toByteArray();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      logger.error(<span class="string">&quot;protostuff serialize error: &quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EMPTY_BYTES;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 反序列化成对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(<span class="type">byte</span>[] bytes, Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bytes == <span class="literal">null</span> || bytes.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Schema&lt;T&gt; schema = getSchema(type);</span><br><span class="line">      <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> schema.newMessage();</span><br><span class="line">      ProtobufIOUtil.mergeFrom(bytes, obj, schema);</span><br><span class="line">      <span class="keyword">return</span> obj;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      logger.error(<span class="string">&quot;protostuff deserialize error: &quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; Schema&lt;T&gt; <span class="title function_">getSchema</span><span class="params">(Class&lt;T&gt; aClass)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (aClass == HashMap.class) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotSupportSerialException</span>(<span class="string">&quot;not support type:&quot;</span> + aClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> RuntimeSchema.getSchema(aClass);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Protobuf是一个很优秀的序列化和反序列化工具，具有较高的效率，并且使用紧凑的二进制码，能够减小内存占用，但是有一些坑，需要我们能够正确的使用。这篇博客就来记录一些Protobuf的使用和一些踩过的坑。&lt;/p&gt;</summary>
    
    
    
    
    <category term="随笔" scheme="https://eoccc.gitee.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="技术笔记" scheme="https://eoccc.gitee.io/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="踩坑" scheme="https://eoccc.gitee.io/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>开发经验教训总结</title>
    <link href="https://eoccc.gitee.io/2022/08/07/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD%E6%80%BB%E7%BB%93/"/>
    <id>https://eoccc.gitee.io/2022/08/07/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD%E6%80%BB%E7%BB%93/</id>
    <published>2022-08-07T14:52:41.000Z</published>
    <updated>2022-10-10T12:40:29.518Z</updated>
    
    <content type="html"><![CDATA[<p>从一个个故障的血泪教训，以及代码的坏味道中，总结一些开发经验。</p><span id="more"></span><h1 id="字段意义唯一性"><a class="markdownIt-Anchor" href="#字段意义唯一性"></a> 字段意义唯一性</h1><p>设计字段的时候，要尽可能保证字段所代表的逻辑的唯一性，不能一个字段控制了多个功能，否则会导致后期理解代码逻辑的成本急剧增加，并且出问题的概率也会增加，甚至是故障。</p><p>一个bad case：</p><blockquote><p>在我们的代码中存在了这样一个字段：productTypeCode，这个字段最开始是代表了商品类型，后来这个字段在后来的业务中被用作了其他的功能，比如上游系统中对商品进行分类，识别特殊的商品，因此，这个字段在业务代码中不断的被修改，有时候会换成另一个值，有时候加个后缀等等，以至于到了后来，我们都不知道这个字段到底是用来干嘛。</p></blockquote><h1 id="偶发性问题"><a class="markdownIt-Anchor" href="#偶发性问题"></a> 偶发性问题</h1><p>在beta环境偶发的问题，到了线上就一定会爆发，一定要查出根源，不要心存侥幸！不要心存侥幸！不要心存侥幸！</p><h1 id="map使用"><a class="markdownIt-Anchor" href="#map使用"></a> Map使用</h1><p>从map里面取出来的东西一定要进行判空处理，即使当前业务代码里面没有问题，随着代码的迭代，后面还是很有可能会发生NPE。不要成为水管工。</p><h1 id="删除字段"><a class="markdownIt-Anchor" href="#删除字段"></a> 删除字段</h1><p>随着业务的发展，线上的字段会越来越多，也会有一些字段被废弃掉。这时如果要删除（或者不赋值）没有用的字段，一定要慎重慎重再慎重，千万要理清楚字段的用途，以及影响范围，做好测试！否则可能会出现一些不可预知的bug，甚至是故障。</p><h1 id="业务降级"><a class="markdownIt-Anchor" href="#业务降级"></a> 业务降级</h1><p>我们都知道当业务出现问题的时候，可以选择降级，但是平时开发的时候往往就会忽略了降级，没有做相应的处理，一旦出现问题，可能就会引起全局的崩溃，导致故障。</p><p>开发的时候要尽量保证上线后业务可控，开发是做好开关控制，异常处理等，至少要能兜住一个模块内部的问题，不能影响其他业务。</p><h1 id="工具简单化"><a class="markdownIt-Anchor" href="#工具简单化"></a> 工具简单化</h1><p>开发工具的时候要尽可能将工具设计的简单易用，不要有太多的依赖，或者需要做太多的超过，要尽可能的做到上手即用，因为不是所有人都会去扒代码看工具的逻辑。如果需要配置，也要做到只需要配置一次，后面就可以直接使用。</p><p>一个case：</p><blockquote><p>我们写了一个加载配置的工具，在读配置的时候，会根据不同的配置格式将配置解析成系统可以直接使用的格式，但是新增配置的时候，需要将新配置的key添加到相应格式的key集合中，有人开发的时候就会忘记添加key，导致读取不到新配置。</p></blockquote><p>老代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; listFormatLabels = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, List&lt;String&gt;&gt; listMap = Maps.newConcurrentMap();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initLabel</span><span class="params">()</span> &#123;</span><br><span class="line">  listFormatLabels.clear();</span><br><span class="line">  listFormatLabels.add(<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line">  listFormatLabels.add(<span class="string">&quot;bbb&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resolveListProperties</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (CollectionUtils.isEmpty(listFormatLabels)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (String label : listFormatLabels) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">config</span> <span class="operator">=</span> getConfig(label);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(config)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] split = config.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    listMap.put(label, Lists.newArrayList(split));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后，我们采取了动态解析的方式，取配置的时候再解析，并将解析后的配置存储起来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, List&lt;String&gt;&gt; listMap = Maps.newConcurrentMap();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getList</span><span class="params">(String label, List&lt;String&gt; defaultValue)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (listMap.containsKey(label)) &#123;</span><br><span class="line">    <span class="keyword">return</span> listMap.get(label);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  List&lt;String&gt; result = defaultValue;</span><br><span class="line">  <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> configMap.get(label);</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.isNotBlank(value)) &#123;</span><br><span class="line">    result = SplitterUtil.split2List(value, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  listMap.put(label, result);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="防腐层"><a class="markdownIt-Anchor" href="#防腐层"></a> 防腐层</h1><p>开发中往往会忽略防腐层的重要性，直接在业务中直接使用VO（View Object），导致后面修改对象时，需要修改一大片。所以要尽可能做好防腐，在业务中使用DTO（Data Transfer Object）。</p><h1 id="静态代码块"><a class="markdownIt-Anchor" href="#静态代码块"></a> 静态代码块</h1><p>类加载的顺序对于静态变量和静态代码块的执行顺序是按顺序执行的，因此我们最好把静态变量放在静态代码块之前，避免执行静态代码块的时候，静态变量还没有初始化，从而导致异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStatic</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">//     1</span></span><br><span class="line"><span class="comment">//     null</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">从代码的坏味道中，总结一些开发经验。</summary>
    
    
    
    
    <category term="随笔" scheme="https://eoccc.gitee.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>kafka客户端</title>
    <link href="https://eoccc.gitee.io/2022/07/19/kafka%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    <id>https://eoccc.gitee.io/2022/07/19/kafka%E5%AE%A2%E6%88%B7%E7%AB%AF/</id>
    <published>2022-07-19T14:52:41.000Z</published>
    <updated>2022-08-23T02:18:29.082Z</updated>
    
    <content type="html"><![CDATA[<p>总结kafka客户端的分区策略、幂等性和事物。</p><span id="more"></span><h1 id="分区分配策略"><a class="markdownIt-Anchor" href="#分区分配策略"></a> 分区分配策略</h1><p>消费者消费消息之前，首先得进行分区分配，kafka提供了三种分区分配策略。</p><ol><li><p>RangeAssignor</p><p>kafka会先按照分区总数和消费者总数进行整除，获得一个跨度，然后按照分区跨度进行平均分配，确保分区尽可能平均的分配给所有的消费者。对于剩余的分区（分区总数 % 消费者总数），则前面的消费者（消费者名称按字典序排序）会多分配一个分区。</p><p>假设 n=分区数/消费者数量， m=分区数%消费者数量，那么前 m 个消费者每个分配 n+1 个 分区，后面的(消费者数量～m)个消费者每个分配 n个分区。</p><p>这种分配方式存在一个问题，如果存在多个topic的分区不是消费者总数的整数倍，那么排在前面的消费者会被多分配多个分区。</p><blockquote><p>假设有两个topic，每个topic有4个分区，分配结果为：</p><p>Consumer0:  t0p0,tp1, t1p0,t1p1</p><p>Consumer1:  t0p2,t0p3, t1p2,t1p3</p><p>但是如果有两个topic，且个topic有3个分区，分配结果为：</p><p>Consumer0:  t0p0,tp1, t1p0,t1p1</p><p>Consumer1:  t0p2,t1p2</p></blockquote></li><li><p>RoundRobinAssignor</p><p>将消费组内所有的消费者及消费者订阅的所有topic的分区按照字典序排序，然后通过轮询的方式将分区依此分配给每个消费者。</p><p>这种分配方式如果消费组内所有的消费者订阅的topic都是相同的，那么分区会被很均匀的分配给每个消费者，但是如果消费者订阅的topic不同，就会导致分配不均匀。</p><blockquote><p>假设消费者C0订阅了主题t0；假设消费者C1订阅了主题t0和t1；假设消费者C2订阅了主题t0，t1和t2。t0、t1、t2的分区数分别为1、2、3。此时分配结果为：</p><p>C0: t0p0</p><p>C1: t1p0</p><p>C2: t1p1, t2p0,t2p1,t2p2</p><p>这种分配方式不完美，因为可以将 t1p1分配给C1。</p></blockquote></li><li><p>StickyAssignor</p><p>这是目前最优秀的分区分配策略。Kafka从0.11x开始引入这种分配策略，尽可能保证：分区分配均匀，分区分配尽可能与上一次分配相同</p><p>再分配的时候，会将需要分配的分区平均的分配给消费者。</p><blockquote><p>假设当前的分区分配为：</p><p>C0: t0p0, t1p1, t3p0</p><p>C1: t0p1, t201, t3p1</p><p>C2: t1p0, t2p1</p><p>消费者C1脱离了消费组，则分配结果为：</p><p>C0: t0p0, t1p1, t3p0, <strong>t201</strong></p><p>C2: t1p0, t2p1, <strong>t0p1, t3p1</strong></p><p>RoundRobinAssignor中提到的例子，使用StickyAssignor的分配结果为：</p><p>C0: t0p0</p><p>C1: t1p0, <strong>t1p1</strong></p><p>C2: t2p0,t2p1,t2p2</p></blockquote></li><li><p>自定义分区分配策略</p><p>实现PartitionAssignor接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PartitionAssignor</span> &#123;</span><br><span class="line">  <span class="comment">//提供订阅的消息</span></span><br><span class="line">  Subscription <span class="title function_">subscription</span><span class="params">(Set&lt;String&gt; topics)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//实现具体的分配逻辑</span></span><br><span class="line">  Map&lt;String, Assignment&gt; <span class="title function_">assign</span><span class="params">(Cluster metadata, Map&lt;String, Subscription&gt; subscriptions)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//执行分配的时候会调用这个方法</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">onAssignment</span><span class="params">(Assignment assignment)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">onAssignment</span><span class="params">(Assignment assignment, <span class="type">int</span> generation)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.onAssignment(assignment);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这个分配策略的名字</span></span><br><span class="line">  String <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="幂等"><a class="markdownIt-Anchor" href="#幂等"></a> 幂等</h1><p>kafka开启幂等性功能：</p><blockquote><ol><li>将生产者的<code>enable.idempotence</code>配置为true，默认为false</li><li>生产者客户端的retries必须大于0</li><li><code>max.in.flight.requests.per.connection</code>不能大于5</li><li>acks设置为-1</li></ol></blockquote><p>为了实现幂等性，kafka引入了producer id（PID）和sequence number的概念。kafka会为每个producer分配一个id，每个生产者发送到每个分区的每条消息都有一个序列号，每发送一条消息，&lt;PID，分区&gt;对应的序列号就会加1。</p><p>broker端会为每个&lt;PID，分区&gt;维护一个序列号：</p><blockquote><p>当收到消息时，只有序列号（SN_new）比旧的序列号（SN_old）大1时，即SN_new=SN_old+1，才会接受它</p><p>如果新的序列号小于旧的序列号，则说明这是重复消息，会被丢弃</p><p>如果SN_new&gt;SN_old+1，则说明中间有消息没有写入，出现乱序，即有消息丢失，会抛出OutOfOrderSequenceException异常</p></blockquote><h1 id="事务"><a class="markdownIt-Anchor" href="#事务"></a> 事务</h1><p>要开启事务功能，首先必须开启生产者的幂等性功能。</p><p>通过事务，可以保证跨生产者会话的消息幂等发送和事务恢复。</p><p>需要手动的指定transactionalId，transactionalld与PID一一对应，同时通过一个单调递增的producer epoch保证transactionalld的唯一性。</p><p>Kafka 并不能保证己提交的事务中的所有消息都能够被消费 :</p><blockquote><ol><li>对采用日志压缩策略的主题而言，事务中的某些消息有可能被清理(相同 key 的消息， 后写入的消息会覆盖前面写入的消息)。</li><li>事务中消息可能分布在同一个分区的多个日志分段(LogSegment)中，当老的日志分 段被删除时，对应的消息可能会丢失。</li><li>消费者可以通过 seek()方法访问任意offset的消息，从而可能遗漏事务中的部分消息。</li><li>消费者在消费时可能没有分配到事务内的所有分区，因此它也就不能读取事务中的所有消息。</li></ol></blockquote>]]></content>
    
    
    <summary type="html">kafka客户端的一些细节。</summary>
    
    
    
    
    <category term="中间件" scheme="https://eoccc.gitee.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="kafka" scheme="https://eoccc.gitee.io/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>软引用和弱的使用场景</title>
    <link href="https://eoccc.gitee.io/2022/07/10/%E8%BD%AF%E5%BC%95%E7%94%A8%E5%92%8C%E5%BC%B1%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>https://eoccc.gitee.io/2022/07/10/%E8%BD%AF%E5%BC%95%E7%94%A8%E5%92%8C%E5%BC%B1%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2022-07-09T16:00:00.000Z</published>
    <updated>2022-08-01T04:58:42.278Z</updated>
    
    <content type="html"><![CDATA[<p>我们日常开发中一般不会使用到软引用，因此对这块可能比较陌生，看过一些使用场景，但是过一段时间可能就忘记了，这篇博客就整理一下软引用的使用场景。</p><span id="more"></span><h1 id="软引用"><a class="markdownIt-Anchor" href="#软引用"></a> 软引用</h1><p>软引用的特点：当系统的内存不足时，进行回收，否则不会回收。</p><p>应用场景：</p><blockquote><ol><li>保存网页资源，如图片等</li><li>Spring 缓存配置属性缓存–SoftReferenceConfigurationPropertyCache</li></ol></blockquote><h1 id="弱引用"><a class="markdownIt-Anchor" href="#弱引用"></a> 弱引用</h1><p>软引用的特点：下一次GC的时候会回收</p><p>应用场景：</p><blockquote><ol><li>ThreaLocal中的map实现，此map继承了弱引用WeakReference，防止map中的key引用的对象无法被回收（线程一直处于活跃状态，导致ThreaLocal不会被回收）；</li><li>一些高速缓存场景，缓存仅在GC之间生效。</li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们日常开发中一般不会使用到软引用，因此对这块可能比较陌生，看过一些使用场景，但是过一段时间可能就忘记了，这篇博客就整理一下软引用的使用场景。&lt;/p&gt;</summary>
    
    
    
    
    <category term="随笔" scheme="https://eoccc.gitee.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="技术笔记" scheme="https://eoccc.gitee.io/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>kafka消费者</title>
    <link href="https://eoccc.gitee.io/2022/06/21/kafka%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    <id>https://eoccc.gitee.io/2022/06/21/kafka%E6%B6%88%E8%B4%B9%E8%80%85/</id>
    <published>2022-06-21T14:52:41.000Z</published>
    <updated>2022-08-07T17:14:35.504Z</updated>
    
    <content type="html"><![CDATA[<p>Kafka的消费者负责订阅topic，并从订阅的topic上拉取消息。kafka的消费层还有一个消费组（consumer group），每个consumer都有一个消费组，消息会发给订阅了这个topic的<strong>所有</strong>消费组，并由消费组中的<strong>一个</strong>消费者进行消费。</p><span id="more"></span><h1 id="消费者与消费组"><a class="markdownIt-Anchor" href="#消费者与消费组"></a> 消费者与消费组</h1><p>某个主题中共有4个分区(Partition):P0、P1、P2、P3。有两个消费组A和B都订阅了这个主题，消费组A中有4个消费者(C0、C1、C2和C3)，消费组B中有2个消费者C4和C5)。按照Kafka默认的规则，最后的分配结果是消费组A中的每一个消费者分配到1个分区，消费组B中的每一个消费者分配到2个分区，两个消费组之间互不影响。每个消费者只能消费所分配到的分区中的消息。换言之，每一个分区只能被一个消费组中的一个消费者所消费。</p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4ypbl8zq6j20nc0eeab4.jpg" alt="image-20220803203252462" style="zoom:50%;"><p>如果消费者的个数大于分区的个数，则有的消费者会分配不到分区。</p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4ypbfi2vtj20my0f2dgw.jpg" alt="image-20220803203324669" style="zoom:40%;"><p>一个消费者只会属于一个消费组，消费模式可以分为点对点模式和发布订阅模式：</p><blockquote><ul><li><p>点对点模式：</p><p>所有消费者都属于同一个消费组，partition会均衡地分配给每一个消费者，从而消息会均衡地发送给消费者，每条消息只会被消费一次</p></li><li><p>发布/订阅模式（广播）：</p><p>每个消费者属于一个单独的消费组，每个消费组都订阅topic，消息会发送给所有的消费组，即一条消息会被每个消费者都消费一遍</p></li></ul></blockquote><h1 id="订阅消息"><a class="markdownIt-Anchor" href="#订阅消息"></a> 订阅消息</h1><p>Kafka一个消费者可以订阅一个或多个消息主题，支持多种订阅消息的方式。</p><ul><li><p>订阅一个或多个topic</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(Collection&lt;Str ing&gt; topics)</span></span><br></pre></td></tr></table></figure></li><li><p>根据正则表达式订阅主题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(Pattern pattern)</span></span><br></pre></td></tr></table></figure></li><li><p>订阅指定的分区</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">assign</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span></span><br></pre></td></tr></table></figure><p>TopicPartition对象中包含了topic和partation两个参数。</p></li></ul><p>如果我们需要知道某个topic的分区信息，可以通过<code>KafkaConsumer.partitionsFor(String tpoic)</code>进行查询，返回一个<code>List&lt;PartitionInfo&gt;</code>列表，PartitionInfo包含了这个topic的分区信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Part</span>工tioninfo &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String topic;              <span class="comment">//topic</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> partition;             <span class="comment">//分区</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Node leader;               <span class="comment">//这个分区的leader节点</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span>  Node[] replicas;          <span class="comment">//所有副本 ASR</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span>  Node[] inSyncReplicas;    <span class="comment">//同步副本 ISR</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Node[] offlineReplicas;    <span class="comment">//离线副本 OSR</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="消费消息"><a class="markdownIt-Anchor" href="#消费消息"></a> 消费消息</h1><p>Kafka采用poll的方式从服务端拉取消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ConsumerRecords&lt;K, V&gt; <span class="title function_">poll</span><span class="params">(<span class="keyword">final</span> Duration timeout)</span></span><br></pre></td></tr></table></figure><p>ConsumerRecords的内部包括了ConsumerRecord，用来存储一次拉取获得的消息集，提供了一个iterator来遍历消息集内部的消息。</p><p>我们可以通过下面的方法获取一个分区的消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;ConsumerRecord&lt;K, V&gt; <span class="title function_">records</span><span class="params">(TopicPartition partition)</span></span><br></pre></td></tr></table></figure><p>ConsumerRecord中比较关键的属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerRecord</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String topic;                 <span class="comment">//主题</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> partition;                <span class="comment">//分区</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> offset;                  <span class="comment">//这个消息在分区中的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> timestamp;               <span class="comment">//时间戳</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TimestampType timestampType;  <span class="comment">//时间戳的类型，有CreateTime和LogAppendTime两种类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> serializedKeySize;        <span class="comment">//key序列化器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> serializedValueSize;      <span class="comment">//value序列化器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Headers headers;              <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> K key;                        <span class="comment">//消息的key</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> V value;                      <span class="comment">//消息的value</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Optional&lt;Integer&gt; leaderEpoch;<span class="comment">//leader的纪元</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Long checksum;             <span class="comment">//CRC32校验值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="位移提交"><a class="markdownIt-Anchor" href="#位移提交"></a> 位移提交</h1><p>Kafka中每条消息都有唯一的offset，用来表示消息在分区中的位置。消费者也保存了一个offset，用来记录消费到分区中某个消息所在的位置。</p><p>在旧的消费者客户端中，offset是保存在zookeeper中的，而在新的消费者客户端中，是保存在kafka的内部主题__consumer_offsets中。</p><p>如果消费者当前消费到了x，需要提交的位移为x+1。</p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4ypavsxvoj20l80awaaj.jpg" alt="image-20220807151328147" style="zoom:50%;"><p><strong>消费者提交偏移量的时机</strong></p><p>消费者提交偏移量，有可能会造成重复消费和消息丢失现象。</p><blockquote><ul><li>拉取到消息立即提交offset，如果这批消息消费的过程中出现了异常，导致部分消息没有消费，就会导致消息丢失</li><li>消息消费完再提交offset，如果这批消息消费的过程中出现了异常，消费了部分消息，但是由于没有消费完，没有提交offset，就会导致消息重复消费</li></ul></blockquote><p>kafka默认是自动提交的，即定期提交，默认是5m提交一次。<code>enable.auto.commit</code>开启自动提交，<code>auto.commit.interval.ms</code>配置提交的时间。自动提交的操作是在KafkaConsumer#poll()中完成的。消费者每隔5秒就会拉取每个分区中的最小offset进行提交，另外，每次向服务端发起拉取消息的请求的时候，都会检查是否可以提交offset，如果可以，就会提交。</p><p>自动提交存在的问题：</p><blockquote><ul><li>重复消费：消费者拉取了一批消息x+1～x+5，消费到x+3的时候，自动提交了一次offset，这一批消息消费完了，但是拉取消息的时候没有提交offset（条件不满足，还不可以自动提交），然后消费者继续消费，消费到x+7的时候，消费者崩溃了，就需要重新从x+3的offset处开始消费，就会导致重复消费。可以减小自动提交的时间窗口。</li><li>消息丢失：异步拉取消息，并发消费这种情况下会导致消息丢失。比如有一个异步线程一直在拉取消息，然后保存在本地，然后有两个线程并发的消费消息，线程A消费x+1～x+5的batch，线程B消费x+6～x+10的batch，消费者自动提交了x+8的offset，但是线程A才消费到了x+3，这是线程A发生了异常，重新消费的时候，就会从x+6的位置开始消费，x+3～x+5的消息就会丢失，而且x+6～x+10的消息会被重复消费。</li></ul></blockquote><p>kafka可以手动提交偏移量，需要将配置<code>enable.auto.commit</code>关闭，然后使用<code>commitSync()</code>方法提交offset。</p><p>一个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (isRunning.get()) &#123;</span><br><span class="line">ConsumerRecords&lt;String, String&gt; records= consumer.poll(<span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line"><span class="comment">//do some logical processing .</span></span><br><span class="line">&#125;</span><br><span class="line">  consumer.commitSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="控制消费"><a class="markdownIt-Anchor" href="#控制消费"></a> 控制消费</h1><p>KafkaConsumer可以使用pause方法暂停消费，使用resume方法恢复消费：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pause</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resume</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span></span><br></pre></td></tr></table></figure><p>关闭客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(Duration timeout)</span></span><br></pre></td></tr></table></figure><h1 id="指定消费位移"><a class="markdownIt-Anchor" href="#指定消费位移"></a> 指定消费位移</h1><p>当一个新的消费组建立的时候，或订阅一个新的tpoic的时候，或当__consumer_offsets主题中关于这个消费组的偏移量消息过期后，没有可以查找的offset，这时会根据消费者的<code>auto.offset.reset</code>配置来决定从什么地方开始消费：</p><blockquote><ul><li>latest：默认值，从下一条写入的消息开始消费</li><li>earliest：从起始处开始消费</li><li>none：抛出NoOffsetForPartitionException异常</li></ul></blockquote><p>kafka还可以通过seek()方法，更细粒度的从指定的位置开始消费。seek()只能重置分配到分区的消费者的位置，所以在重置之前，还得先poll()一次。</p><p>kafka还提供了两个快速seek的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">seekToBeginning</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">seekToEnd</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span></span><br></pre></td></tr></table></figure><p>另外可以通过offsetsForTimes方法获取指定时间的offset：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;TopicPartition, OffsetAndTimestamp&gt; <span class="title function_">offsetsForTimes</span><span class="params">(Map&lt;TopicPartition, Long&gt; timestampsToSearch)</span></span><br></pre></td></tr></table></figure><p>kafka有再均衡监听器ConsumerRebalanceListener，可以在再均衡之前和重新分配分区之后做一些操作，如在再均衡之前提交当前的offset</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConsumerRebalanceListener</span> &#123;</span><br><span class="line">  <span class="comment">//再均衡之前调用</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">onPartitionsRevoked</span><span class="params">(Collection&lt;TopicPartition&gt; var1)</span>;</span><br><span class="line"><span class="comment">//重新分配分区之后调用</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">onPartitionsAssigned</span><span class="params">(Collection&lt;TopicPartition&gt; var1)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="消费者拦截器"><a class="markdownIt-Anchor" href="#消费者拦截器"></a> 消费者拦截器</h1><p>消费者拦截器可以在消费消息或者提交偏移量的时候做一些操作，实现ConsumerInterceptor接口即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConsumerInterceptor</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">Configurable</span>, AutoCloseable &#123;</span><br><span class="line">  <span class="comment">//消费消息之前会调用这个方法</span></span><br><span class="line">  <span class="comment">//我们可以通过这个方法修改消息，或者做一些过滤等</span></span><br><span class="line">  ConsumerRecords&lt;K, V&gt; <span class="title function_">onConsume</span><span class="params">(ConsumerRecords&lt;K, V&gt; var1)</span>;</span><br><span class="line">  <span class="comment">//提交偏移量之前会调用</span></span><br><span class="line">  <span class="comment">//我们可以通过这个方法获取一些偏移量提交的细节</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">onCommit</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; var1)</span>;</span><br><span class="line">  <span class="comment">//关闭的时候会调用</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Kafka的消费者负责订阅topic，并从订阅的topic上拉取消息。kafka的消费层还有一个消费组（consumer group），每个consumer都有一个消费组，消息会发给订阅了这个topic的&lt;strong&gt;所有&lt;/strong&gt;消费组，并由消费组中的&lt;strong&gt;一个&lt;/strong&gt;消费者进行消费。&lt;/p&gt;</summary>
    
    
    
    
    <category term="中间件" scheme="https://eoccc.gitee.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="kafka" scheme="https://eoccc.gitee.io/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>缓存淘汰算法总结</title>
    <link href="https://eoccc.gitee.io/2022/06/20/%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://eoccc.gitee.io/2022/06/20/%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2022-06-19T16:00:00.000Z</published>
    <updated>2022-09-22T13:25:47.574Z</updated>
    
    <content type="html"><![CDATA[<p>以前看到过一些缓存淘汰的算法，觉得很是精妙，比如大名鼎鼎的LRU、LFU、FIFO，以及mysql版的LRU，redis的缓存淘汰策略，GuavaCache的缓存淘汰算法，等等。写篇博客总结一下～～</p><span id="more"></span><h1 id="lru"><a class="markdownIt-Anchor" href="#lru"></a> LRU</h1><p>LRU(Least Recently Used)：最近最少使用算法。</p><p>核心思想：这种算法认为最近使用的数据是热点数据，很有可能被再次使用，而最近很少使用的数据是冷门数据，很有可能不再使用。当缓存容量满了的时候，优先淘汰最近最少使用的数据。</p><p>缓存满的状态下：</p><blockquote><ol><li>读取一条缓存，将更新这条缓存的使用时间</li><li>插入一条缓存，将移除时间最远的一条缓存</li></ol></blockquote><h2 id="lru实现"><a class="markdownIt-Anchor" href="#lru实现"></a> LRU实现</h2><p>LRU可以使用LinkedHashMap实现，从而达到O(1)的查询复杂度和更新复杂度。Hash实现O(1)的查询复杂度，链表维护缓存的新鲜度，靠近链表头部的数据是冷门数据，靠近链表尾部的数据是热点数据。</p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h4a9md6paaj20su0ay0tk.jpg" alt="image-20220713094354095" style="zoom:50%;"><p><em>LinkedHashMap提供了accessOrder选项，设置为true的时，访问node会将node移动到链表尾部。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">  Node&lt;K,V&gt; e;</span><br><span class="line">  <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (accessOrder)</span><br><span class="line">    afterNodeAccess(e);</span><br><span class="line">  <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问后的处理</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123;</span><br><span class="line">  LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">  <span class="comment">//如果accessOrder为true，会将node移动到尾部</span></span><br><span class="line">  <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    p.after = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">      head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      b.after = a;</span><br><span class="line">    <span class="keyword">if</span> (a != <span class="literal">null</span>)</span><br><span class="line">      a.before = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      last = b;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="literal">null</span>)</span><br><span class="line">      head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      p.before = last;</span><br><span class="line">      last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">    tail = p;</span><br><span class="line">    ++modCount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>LinkedHashMap重写了HashMap的newNode方法，put的时候会将新创建的node放到node的尾部。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入方法使用的是HashMap的put方法</span></span><br><span class="line"><span class="comment">//hashMap.put -&gt; hashMap.putVal -&gt; LinkedHashMap.newNode</span></span><br><span class="line">Node&lt;K,V&gt; <span class="title function_">newNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> &#123;</span><br><span class="line">  LinkedHashMap.Entry&lt;K,V&gt; p = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">  linkNodeLast(p);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lru查询"><a class="markdownIt-Anchor" href="#lru查询"></a> LRU查询</h3><p>当缓存中不包含查询的key时，返回空。</p><p>当查询到数据时，需要将缓存移动到链表的尾部。</p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h4a9m9z2lqj20tg0bewfg.jpg" alt="image-20220713094854303" style="zoom:50%;"><h3 id="lru更新"><a class="markdownIt-Anchor" href="#lru更新"></a> LRU更新</h3><p>缓存容量未满时：</p><ul><li>缓存中不包含key，直接在链表的尾部插入新的缓存</li><li>缓存中包含key，更新缓存的value，并移动到链表的尾部</li></ul><p>缓存容量满时：</p><ul><li>缓存中不包含key，移除链表头部的数据，然后在链表的尾部插入新的数据</li><li>缓存中包含key，更新缓存的value，并移动到链表的尾部</li></ul><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h4a9m9moz2j20tg0bewfg.jpg" alt="image-20220713095155195" style="zoom:50%;"><h1 id="lfu"><a class="markdownIt-Anchor" href="#lfu"></a> LFU</h1><p>LFU(Least Frequently Used)：最近最不常用算法，根据数据的历史访问频率来淘汰数据。</p><p>核心思想：最近使用频率高的数据很大概率将会再次被使用，而最近使用频率低的数据很大概率不会再使用。淘汰使用频率最小的数据。</p><p>缺点：如果一条sh数据用的频率非常高，然后在某一时刻废弃不用了，这条数据会在很长时间内存在于缓存中，不能被淘汰。</p><h2 id="lfu实现"><a class="markdownIt-Anchor" href="#lfu实现"></a> LFU实现</h2><p>LFU也使用hash+链表的实现，同样可以基于LinkedHashMap实现，但是要重写get方法。</p><h3 id="lfu查找"><a class="markdownIt-Anchor" href="#lfu查找"></a> LFU查找</h3><p>在LFU中查找并访问一条数据后，会：</p><blockquote><ol><li>将这个node的访问频率加1</li><li>将这个node移动到相同频率的node的前面</li></ol></blockquote><p>如：A(10)-&gt;B(9)-&gt;C(9)-&gt;D(8)</p><p>当D被访问后，会变成：A(10)-&gt;D(9)-&gt;B(9)-&gt;C(9)</p><h3 id="lfu插入"><a class="markdownIt-Anchor" href="#lfu插入"></a> LFU插入</h3><p>当插入一条缓存时：</p><blockquote><ol><li>如果缓存容量未满，将node放到链表尾部</li><li>如果缓存容量满了，移除链表尾部的一个node，然后将新的node放到链表尾部</li></ol></blockquote><h1 id="arc"><a class="markdownIt-Anchor" href="#arc"></a> ARC</h1><p>ARC(Adaptive Replacement Cache): 自适应缓存替换算法，它结合了LRU与LFU，来获得可用缓存的最佳使用。</p><p>ARC将整个Cache分成四部分：</p><blockquote><ul><li>最近最多使用的缓存链表，LRU链表</li><li>最近最频繁使用的缓存链表，LFU链表</li><li>最近从LRU表中淘汰的缓存链表，ghost LRU链表，只存储key，不存储真正的数据</li><li>最近从LFU表中淘汰的缓存链表，ghost LFU链表，只存储key，不存储真正的数据</li></ul></blockquote><p>初始时，LRU和LFU的空间各占一半，后续会动态适应调整partion的位置。</p><h2 id="arc查找"><a class="markdownIt-Anchor" href="#arc查找"></a> ARC查找</h2><p>先从LRU缓存中查找，如果命中LRU中的缓存，说明这个缓存时访问频率高的缓存，将node移动到LFU缓存中：</p><blockquote><ol><li>如果在LRU链表中查找到缓存，将这个node移动到LFU链表中。<ul><li>如果LFU链表没满，直接追加到尾部</li><li>如果LFU链表满了，将LFU尾部的node的key移动到<strong>ghost LFU</strong>链表中，再将新的node追加进去</li><li>ghost LFU链表按照LFU算法进行淘汰</li></ul></li><li>如果在LRU链表中没查找到缓存，从LFU中查找</li><li>如果LRU缓存和LFU缓存都没有查找到，从磁盘加载数据<ul><li>如果缓存的key存在于ghost LRU中，则将LRU链表的长度加1，LFU链表的长度减1，将缓存插入到LRU链表中</li><li>如果缓存的key存在于ghost LFU中，则将LFU链表的长度加1，LRU链表的长度减1，将缓存插入到LFU链表中</li></ul></li></ol></blockquote><h2 id="arc插入"><a class="markdownIt-Anchor" href="#arc插入"></a> ARC插入</h2><p>任何缓存的插入都要先插入到LRU缓存中：</p><blockquote><ol><li><p>如果LRU缓存没有满，直接将缓存追加到LRU缓存的尾部</p></li><li><p>如果LRU缓存满了：</p><ul><li><p>将LRU缓存的头部节点移动到<strong>ghost LRU</strong>中</p></li><li><p>将新的缓存插入到LRU的尾部</p></li><li><p>ghost LRU按照LRU算法进行淘汰</p></li></ul></li></ol></blockquote><h1 id="w-tinylfu"><a class="markdownIt-Anchor" href="#w-tinylfu"></a> W-TinyLFU</h1><p>W-TinyLFU（Window Tiny Least Frequently Used）是对LFU的的优化和加强。</p><p>W-TinyLFU算法分为三个区域，WindowLRU区域、TinyLFU区域、SLRU-主Cache区域：</p><blockquote><ol><li><p>缓存插入时，先进入WindowLRU区</p></li><li><p>WindowLRU区淘汰的数据进入TinyLFU区</p><p>被WindowLRU区淘汰，说明这个数据不是最近需要访问的数据，但是有可能其访问频率很高，进入TinyLFU区</p></li><li><p>TinyLFU区满了以后，将频率最高的数据移动到SLRU区</p></li><li><p>SLRU区满了以后，将淘汰的数据重新放到TinyLFU区</p></li></ol></blockquote><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h4bii54r6ij21ia0nywgr.jpg" alt="img" style="zoom:35%;"><p>另外，LFU通常使用一个map来保存key的访问频率，由于使用map，就会产生hash冲突。caffeine使用了Count-Min Sketch算法存储访问频率。</p><h2 id="hash算法"><a class="markdownIt-Anchor" href="#hash算法"></a> hash算法</h2><p>Count-Min Sketch算法类似于布隆过滤器，采用4个hash函数进行hash计算，取得四个位置的频率后，取最小值。另外，Count-Min Sketch算法使用四个数组来保存频率。</p><p><img src="/.io//34d432e4f2cd21c4ef18c76074940f81-20220718234745930.png" alt="img"></p><h2 id="驱逐策略"><a class="markdownIt-Anchor" href="#驱逐策略"></a> 驱逐策略</h2><p>但是存在一个问题，如果一个访问频率超级高的数据，突然没有用了，会一直在SLRU区和TinyLFU区中倒腾，就是不能被淘汰，因此caffeine还提供了三种驱逐策略：</p><blockquote><ol><li><p>基于大小：</p><p>可以使用Caffeine.maximumSize(long)方法来指定缓存的最大容量。当缓存超出这个容量的时候，会使用<a href="https://github.com/ben-manes/caffeine/wiki/Efficiency">Window TinyLfu策略</a>来删除缓存。</p></li><li><p>基于时间：</p><ul><li>expireAfterAccess(long, TimeUnit)：在最后一次访问或者写入后开始计时，在指定的时间后过期。</li><li>expireAfterWrite(long, TimeUnit)： 在最后一次写入缓存后开始计时，在指定的时间后过期。</li><li>expireAfter(Expiry)： 自定义策略，过期时间由Expiry实现独自计算。</li></ul></li><li><p>基于引用：没有引用指向数据时，才会驱逐缓存。</p></li></ol></blockquote><h1 id="一点想法"><a class="markdownIt-Anchor" href="#一点想法"></a> 一点想法</h1><p>对于某些缓存在一定时间内访问的频率很高，积攒了很高的访问频率，导致这些缓存长期存在而不能被淘汰，可以定时对缓存的使用频率进行平滑处理，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newFrequency = f(oldFrequency) </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">缓存淘汰算法LRU、LFU、W-TinyLFU等</summary>
    
    
    
    
    <category term="随笔" scheme="https://eoccc.gitee.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="技术笔记" scheme="https://eoccc.gitee.io/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>kafka生产者</title>
    <link href="https://eoccc.gitee.io/2022/06/19/kafka%E7%94%9F%E4%BA%A7%E8%80%85/"/>
    <id>https://eoccc.gitee.io/2022/06/19/kafka%E7%94%9F%E4%BA%A7%E8%80%85/</id>
    <published>2022-06-19T14:52:41.000Z</published>
    <updated>2022-08-01T12:22:44.144Z</updated>
    
    <content type="html"><![CDATA[<p>Kafka的生产者发送数据时，先将数据缓存到记录收集器RecordAccumulator中，再由发送线程Sender将消息批量地发送给服务端。</p><span id="more"></span><p>Kafka生产者的客户端是KafkaProducer。发送消息的入口是KafkaProducer.send，提供了同步和异步的方式，异步的方式支持回调功能：</p><blockquote><p>同步：send(ProducerRecord&lt;K, V&gt; record)</p><p>异步：send(ProducerRecord&lt;K, V&gt; record, Callback callback)</p></blockquote><img src="/.io//image-20220731211734632.png" alt="image-20220731211734632" style="zoom:45%;"><h1 id="序列化"><a class="markdownIt-Anchor" href="#序列化"></a> 序列化</h1><p>Kafka在发送消息之前，会先进行序列化，key和value可以使用不同的序列化器：</p><blockquote><ul><li>key的序列化器通过<code>key.serializer</code>配置，默认使用JsonSerializer</li><li>key的序列化器通过<code>value.serializer</code>配置，默认使用JsonSerializer</li></ul></blockquote><p>JsonSerializer底层使用的是<code>com.fasterxml.jackson.databind.ObjectMapper</code>进行序列化。</p><h1 id="选择分区"><a class="markdownIt-Anchor" href="#选择分区"></a> 选择分区</h1><p>Kafka的消息分为有key和没有key两种，通常情况下是没有key的。针对两种情况，有不同的分区逻辑。</p><p><strong>有key的消息</strong></p><p>对于有key的消息，kafka会根据key进行散列，key相同的消息会发送到相同的分区中。</p><p><strong>没有key的消息</strong></p><p>当消息没有指定key时，如果是第一次向服务端发送消息（这个topic还没有分配过分区），则随机分配一个分区，否则采用轮询的方式分配分区。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(String topic, Object key, <span class="type">byte</span>[] keyBytes, Object value, <span class="type">byte</span>[] valueBytes, Cluster cluster)</span> &#123;</span><br><span class="line">  List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line">  <span class="type">int</span> <span class="variable">numPartitions</span> <span class="operator">=</span> partitions.size();</span><br><span class="line">  <span class="comment">// 没有key的时候，随机分配分区</span></span><br><span class="line">  <span class="keyword">if</span> (keyBytes == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 选择分区</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextValue</span> <span class="operator">=</span> nextValue(topic);</span><br><span class="line">    List&lt;PartitionInfo&gt; availablePartitions = cluster.availablePartitionsForTopic(topic);</span><br><span class="line">    <span class="keyword">if</span> (availablePartitions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">part</span> <span class="operator">=</span> Utils.toPositive(nextValue) % availablePartitions.size();</span><br><span class="line">      <span class="keyword">return</span> availablePartitions.get(part).partition();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// no partitions are available, give a non-available partition</span></span><br><span class="line">      <span class="keyword">return</span> Utils.toPositive(nextValue) % numPartitions;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 有key的时候直接根据key的hash值进行散列</span></span><br><span class="line">    <span class="comment">// hash the keyBytes to choose a partition</span></span><br><span class="line">    <span class="keyword">return</span> Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">nextValue</span><span class="params">(String topic)</span> &#123;</span><br><span class="line">  <span class="type">AtomicInteger</span> <span class="variable">counter</span> <span class="operator">=</span> topicCounterMap.get(topic);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">null</span> == counter) &#123;</span><br><span class="line">    <span class="comment">// 如果这个topi是第一次推送消息，随机分配一个分区</span></span><br><span class="line">    counter = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ThreadLocalRandom.current().nextInt());</span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">currentCounter</span> <span class="operator">=</span> topicCounterMap.putIfAbsent(topic, counter);</span><br><span class="line">    <span class="keyword">if</span> (currentCounter != <span class="literal">null</span>) &#123;</span><br><span class="line">      counter = currentCounter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 轮询分配分区</span></span><br><span class="line">  <span class="keyword">return</span> counter.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>直接指定分区</strong></p><p>Kafka支持直接指定分区，可以在创建ProducerRecord的时候，直接指定分区。ProducerRecord提供了多个指定分区的构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(ProducerRecord&lt;K, V&gt; record, <span class="type">byte</span>[] serializedKey, <span class="type">byte</span>[] serializedValue, Cluster cluster)</span> &#123;</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">partition</span> <span class="operator">=</span> record.partition();</span><br><span class="line">  <span class="comment">// 优先使用指定的分区</span></span><br><span class="line">  <span class="keyword">return</span> partition != <span class="literal">null</span> ?</span><br><span class="line">    partition :</span><br><span class="line">  partitioner.partition(</span><br><span class="line">    record.topic(), record.key(), serializedKey, record.value(), serializedValue, cluster);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**注意：**分配分区的时候，会过滤掉不健康的分区。</p><p>kafka节点健康的标准：</p><ol><li>存在于ISR集合中（保持正常的同步）</li><li>于zookeeper保持心跳（健康检查）</li></ol><h1 id="客户端消息收集器"><a class="markdownIt-Anchor" href="#客户端消息收集器"></a> 客户端消息收集器</h1><p>Kafka的生产者发送数据时，先将数据缓存到记录收集器RecordAccumulator中，再由发送线程Sender将消息批量地发送给服务端。</p><p>每个分区都有一个双端队列来缓存客户端的消息，队列中的每个元素是一个批记录（ProducerBatch），如果一个批记录满了，就会创建一个新的批记录，并将已经满的批记录交给sender线程发送到服务端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RecordAccumulator.<span class="type">RecordAppendResult</span> <span class="variable">result</span> <span class="operator">=</span> accumulator.append(tp, timestamp, serializedKey,</span><br><span class="line">                    serializedValue, headers, interceptCallback, remainingWaitMs);</span><br><span class="line"><span class="keyword">if</span> (result.batchIsFull || result.newBatchCreated) &#123;</span><br><span class="line">  <span class="comment">// 如果批记录满了，唤醒sender线程</span></span><br><span class="line">  <span class="built_in">this</span>.sender.wakeup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>批记录的大小通过<code>batch.size</code>来配置，默认是16kb。如果一条消息的大小超过了16kb，会创建一个能够容纳这条消息的批记录。</p><p>另外，如果一个批记录很长时间没有满，sender线程会定时的将批记录发送给服务端，避免过长的延时。延时通过<code>linger.ms</code>来配置，默认是0ms，即有消息就会马上发送到服务端。</p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h4qf68kkg6j20zu0bi0uy.jpg" alt="image-20220727101124764" style="zoom:50%;"><h1 id="客户端消息发送线程"><a class="markdownIt-Anchor" href="#客户端消息发送线程"></a> 客户端消息发送线程</h1><p>Kafka发送消息时，为了减少网络的开销，会将属于一个节点的所有partation的消息放在一个批次，同时进行发送。如果我们有两台服务器，topic有6个partation，每台服务器有3个partation，如果迭代每个partation的批记录，直接发送到主副本节点，则会有6次请求；如果把属于同一个节点的所有partation放在一起发送，就只会有2次请求。</p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h4qf7366v4j20jg0ciabe.jpg" alt="image-20220727203032416" style="zoom:50%;"><p>消息发送线程发送消息的步骤：</p><blockquote><ol><li>获取可以发送的批记录（每个批记录属于一个partation）</li><li>遍历每个批记录，获取每个批记录对应的主副本节点：nodeId</li><li>将所有的批记录以nodeId为key，group成一个map：modeId -&gt; List<ProducerBatch></ProducerBatch></li><li>发送消息到每个主副本节点</li></ol></blockquote><p>客户端发送完消息后，会执行<code>KafkaClient#poll</code>方法，执行回调方法以及一些后续的处理。回调方法时保存在ClientRequest中的，为了在收到服务端返回后能够执行回调方法，发送线程会保存目标节点到客户端请求的映射关系。</p><ul><li><p>**不需要响应的流程 ：**开始发送请求→添加客户端请求到队列→发送请求→请求发送成功→从 队列中删除发送请求→构造客户端响应。</p></li><li><p>**需要晌应的流程：**开始发送请求→添加客户端请求到队列→发送请求→请求发送成功→等待 接收响应→接收响应→接收到完整的响应→从队列中删除客户端请求→构造客户端响应。</p></li></ul><p>整体流程：</p><blockquote><ol><li>KafkaProducer将消息存到消息收集器RecordAccumulator中</li><li>Sender从RecordAccumulator获取消息</li><li>Sender将需要发送的批记录根据目标节点进行分类</li><li>Sender创建ClientRequest</li><li>Sender调用KafkaClient.send方法发送消息（具体实现是NetworkClient）</li><li>NetworkClient调用Selector.send</li><li>Selector创建KafkaChanel，并将请求写入通道</li><li>Sender调用KafkaClient.poll方法触发KafkaChanel真正执行发送，并执行回调方法</li></ol></blockquote><h1 id="生产者拦截器"><a class="markdownIt-Anchor" href="#生产者拦截器"></a> 生产者拦截器</h1><p>生产者拦截器既可以用来在消息发送前做一些准备工作， 比如按照某个规则过滤不符合要 求的消息、修改消息的内容等， 也可以用来在发送回调逻辑前做一些定制化的需求，比如统计 类工作。</p><p>使用生产者拦截器，只需要实现Producerlnterceptor，然后配置<code>interceptor.classes </code>即可，包含三个方法：</p><ol><li>onSend()方法：在将消息序列化和计算分区之前会调用，对消息进行相应 的定制化操作；</li><li>onAcknowledgement()方法：在消息被应答( Acknowledgement)之前或消息发送失败时调用，在callback之前。这个方法在producer的I/O线程中，所以逻辑应该尽量简单，否则会影响消息的发送。</li><li>close()方法：在关闭拦截器时执行一些资源的清理工作。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProducerInterceptor</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">Configurable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ProducerRecord&lt;K, V&gt; <span class="title function_">onSend</span><span class="params">(ProducerRecord&lt;K, V&gt; record)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAcknowledgement</span><span class="params">(RecordMetadata metadata, Exception exception)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="重要的消费者参数"><a class="markdownIt-Anchor" href="#重要的消费者参数"></a> 重要的消费者参数</h1><ol><li><p>acks</p><blockquote><ul><li>acks=1。默认值。生产者需要收到服务端的响应才算发送消息成功。<em>如果服务端leader收到数据，但是follower还没有同步数据，此时leader副本崩溃，会丢失消息。如果发生leader选举，会返回一个错误消息。</em></li><li>acks=0。生产者发送消息之后不需要等待服务端响应。</li><li>acks=-1或acks=all。生产者发送消息之后，需要等待ISR中所有副本都成功写入消息之后，才能收到服务端的成功响应。<em>ISR中只有一个副本时，还是会丢失消息</em></li></ul></blockquote></li><li><p>max.request.size</p><blockquote><p>生产者客户端能发送消息的最大值，默认1MB。修改这个参数的时候还需要修改broker<code>message.max .bytes</code>参数，比如生产者的<code>max.request.size</code>配置成20，但是broker的<code>message.max .bytes</code>配置成10，此时发送了一个15B的消息，服务端就接收不了。</p></blockquote></li><li><p><a href="http://xn--retriesretry-4l2u.backoff.ms">retries和retry.backoff.ms</a></p><blockquote><ul><li><code>retries</code>用来配置生产者的重试次数，默认为0，即发生异常时不重试。如果重试的次数超过配置的次数，仍然失败，就会返回异常</li><li><code>retry.backoff.ms</code>用来配置两次重试之间的时间间隔，默认为100。</li></ul></blockquote><p>Kafka的同一个topic中的消息时有序的，生产者会按照发送的顺序发送给服务端，消费者也可以按照同样的顺序进行消费。如果配置了重试，而且配置的发送消息的并发数大于1（max.in.flight.requests.per .connection），此时第一批消息写入失败，而第二批消息写入成功，就会导致消息的顺序不一致。</p></li><li><p>batch.size</p><blockquote><p>生产者客户端发送消息，一个批次的大小，一个批次满了以后，就会发送到服务端。</p></blockquote></li><li><p><a href="http://linger.ms">linger.ms</a></p><blockquote><p>生产者客户端等待发送一批消息的最长时间，默认为0。即有消息就会发送到服务端。</p></blockquote></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;Kafka的生产者发送数据时，先将数据缓存到记录收集器RecordAccumulator中，再由发送线程Sender将消息批量地发送给服务端。&lt;/p&gt;</summary>
    
    
    
    
    <category term="中间件" scheme="https://eoccc.gitee.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="kafka" scheme="https://eoccc.gitee.io/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>深拷贝和浅拷贝工具</title>
    <link href="https://eoccc.gitee.io/2022/06/14/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%B7%A5%E5%85%B7/"/>
    <id>https://eoccc.gitee.io/2022/06/14/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%B7%A5%E5%85%B7/</id>
    <published>2022-06-14T07:10:35.000Z</published>
    <updated>2022-08-01T04:58:42.278Z</updated>
    
    <content type="html"><![CDATA[<p>前几天写代码的时候，需要拷贝对象，就使用了<code>org.apache.commons.beanutils.BeanUtils</code>的<code>BeanUtils.copyProperties(Object dest, Object orig)</code>拷贝对象，后面又修改了新对象的属性，就导致原对象也被修改了，仔细一研究才发现这个工具只是进行了浅拷贝。索性整理一下现在比较常用的一些深拷贝和浅拷贝工具。</p><span id="more"></span><h2 id="深拷贝"><a class="markdownIt-Anchor" href="#深拷贝"></a> 深拷贝</h2><h3 id="1-orika的mapperfactory"><a class="markdownIt-Anchor" href="#1-orika的mapperfactory"></a> 1. Orika的MapperFactory</h3><p>Orika底层采用了javassist类库生成Bean映射的字节码，之后直接加载执行生成的字节码文件，因此在速度上比使用反射进行赋值会快很多。<strong>线程安全，可以使用单例。推荐！</strong></p><p>首先引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ma.glasnost.orika<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>orika-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以拷贝单个对象，也可以拷贝列表，这里只介绍单个对象的拷贝：</p><ul><li><p>直接克隆对象</p><p>克隆的对象可以不同，深拷贝两个对象相同的属性，跳过不同的属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">orikaClone</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">MapperFactory</span> <span class="variable">mapperFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMapperFactory</span>.Builder().build();</span><br><span class="line">  <span class="type">MapperFacade</span> <span class="variable">mapperFacade</span> <span class="operator">=</span> mapperFactory.getMapperFacade();</span><br><span class="line"></span><br><span class="line">  <span class="type">DemoObj</span> <span class="variable">fromObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoObj</span>();</span><br><span class="line">  fromObj.setStr(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  fromObj.setList(Lists.newArrayList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>));</span><br><span class="line">  <span class="type">DemoObj</span> <span class="variable">toObj</span> <span class="operator">=</span> mapperFacade.map(fromObj, DemoObj.class);</span><br><span class="line">  toObj.setStr(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">  toObj.getList().add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">  System.out.println(JSON.toJSONString(fromObj));</span><br><span class="line">  System.out.println(JSON.toJSONString(toObj));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//&#123;&quot;list&quot;:[&quot;A&quot;,&quot;B&quot;],&quot;str&quot;:&quot;a&quot;&#125;</span></span><br><span class="line"><span class="comment">//&#123;&quot;list&quot;:[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;],&quot;str&quot;:&quot;b&quot;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>拷贝对象属性</p><p>克隆的对象可以不同，深拷贝两个对象相同的属性，跳过不同的属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">orikaCopy</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">MapperFactory</span> <span class="variable">mapperFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMapperFactory</span>.Builder().build();</span><br><span class="line">  <span class="type">MapperFacade</span> <span class="variable">mapperFacade</span> <span class="operator">=</span> mapperFactory.getMapperFacade();</span><br><span class="line"></span><br><span class="line">  <span class="type">DemoObj</span> <span class="variable">fromObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoObj</span>();</span><br><span class="line">  fromObj.setStr(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  fromObj.setList(Lists.newArrayList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>));</span><br><span class="line">  <span class="type">DemoObj</span> <span class="variable">toObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoObj</span>();</span><br><span class="line">  mapperFacade.map(fromObj, toObj);</span><br><span class="line">  toObj.setStr(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">  toObj.getList().add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">  System.out.println(JSON.toJSONString(fromObj));</span><br><span class="line">  System.out.println(JSON.toJSONString(toObj));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//&#123;&quot;list&quot;:[&quot;A&quot;,&quot;B&quot;],&quot;str&quot;:&quot;a&quot;&#125;</span></span><br><span class="line"><span class="comment">//&#123;&quot;list&quot;:[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;],&quot;str&quot;:&quot;b&quot;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="dozer的dozerbeanmapper"><a class="markdownIt-Anchor" href="#dozer的dozerbeanmapper"></a> Dozer的DozerBeanMapper</h3><p>dozer是一种JavaBean的映射工具，类似于apache的BeanUtils。但是dozer更强大，它可以灵活的处理复杂类型之间的映射。不但可以进行简单的属性映射、复杂的类型映射、双向映射、递归映射等，并且可以通过XML配置文件进行灵活的配置。 <strong>线程安全，可以使用单例，性能一般。</strong></p><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.dozer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dozer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>深拷贝属性，对象可以不同，属性不同时跳过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dozerCopy</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">DozerBeanMapper</span> <span class="variable">dozer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DozerBeanMapper</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">DemoObj</span> <span class="variable">fromObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoObj</span>();</span><br><span class="line">  fromObj.setStr(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  fromObj.setList(Lists.newArrayList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>));</span><br><span class="line">  <span class="type">DemoObj2</span> <span class="variable">toObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoObj2</span>();</span><br><span class="line">  dozer.map(fromObj, toObj);</span><br><span class="line">  toObj.setStr(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">  toObj.getList().add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">  System.out.println(JSON.toJSONString(fromObj));</span><br><span class="line">  System.out.println(JSON.toJSONString(toObj));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//&#123;&quot;list&quot;:[&quot;A&quot;,&quot;B&quot;],&quot;str&quot;:&quot;a&quot;&#125;</span></span><br><span class="line"><span class="comment">//&#123;&quot;list&quot;:[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;],&quot;str&quot;:&quot;b&quot;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="利用序列化实现深拷贝"><a class="markdownIt-Anchor" href="#利用序列化实现深拷贝"></a> 利用序列化实现深拷贝</h3><p>利用输入输出流，将旧对象写入到新对象，实现拷贝。<strong>性能低，不推荐。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DeepCloneDemo</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">  String str;</span><br><span class="line">  List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> DeepCloneDemo <span class="title function_">deepClone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">DeepCloneDemo</span> <span class="variable">to</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">DeepCloneDemo</span> <span class="variable">from</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">    <span class="type">PipedOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PipedOutputStream</span>();</span><br><span class="line">    <span class="type">PipedInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PipedInputStream</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      in.connect(out);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">bo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(out);</span><br><span class="line">         <span class="type">ObjectInputStream</span> <span class="variable">bi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(in);) &#123;</span><br><span class="line">      bo.writeObject(from);</span><br><span class="line">      to = (DeepCloneDemo) bi.readObject();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> to;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deepClone</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">DeepCloneDemo</span> <span class="variable">from</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeepCloneDemo</span>();</span><br><span class="line">  from.setStr(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  from.setList(Lists.newArrayList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>));</span><br><span class="line">  <span class="type">DeepCloneDemo</span> <span class="variable">to</span> <span class="operator">=</span> from.deepClone();</span><br><span class="line">  to.setStr(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">  to.getList().add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">  System.out.println(JSON.toJSONString(from));</span><br><span class="line">  System.out.println(JSON.toJSONString(to));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//&#123;&quot;list&quot;:[&quot;A&quot;,&quot;B&quot;],&quot;str&quot;:&quot;a&quot;&#125;</span></span><br><span class="line"><span class="comment">//&#123;&quot;list&quot;:[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;],&quot;str&quot;:&quot;b&quot;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="浅拷贝"><a class="markdownIt-Anchor" href="#浅拷贝"></a> 浅拷贝</h2><h3 id="1-apache的beanutils"><a class="markdownIt-Anchor" href="#1-apache的beanutils"></a> 1. apache的BeanUtils</h3><p>所处的包：<code>org.apache.commons.beanutils.BeanUtils</code></p><p>基于反射拷贝，提供了两个拷贝对象的方法：</p><ul><li><p><code>BeanUtils.cloneBean(final Object bean)</code></p><p>传入一个对象，浅拷贝生成一个新的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apacheClone</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="type">DemoObj</span> <span class="variable">fromObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoObj</span>();</span><br><span class="line">  fromObj.setS(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  fromObj.setL(Lists.newArrayList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>));</span><br><span class="line">  <span class="type">DemoObj</span> <span class="variable">toObj</span> <span class="operator">=</span> (DemoObj) org.apache.commons.beanutils.BeanUtils.cloneBean(fromObj);</span><br><span class="line">  toObj.setStr(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">  toObj.getList().add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">  System.out.println(JSON.toJSONString(fromObj));</span><br><span class="line">  System.out.println(JSON.toJSONString(toObj));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//&#123;&quot;list&quot;:[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;],&quot;str&quot;:&quot;a&quot;&#125;</span></span><br><span class="line"><span class="comment">//&#123;&quot;list&quot;:[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;],&quot;str&quot;:&quot;b&quot;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><code>BeanUtils.copyProperties(final Object dest, final Object orig)</code></p><p>传入两个对象，浅拷贝相同的属性的值。两个对象的类型可以不一样，属性及属性类型相同即可，忽略不同的属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apacheCopy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="type">DemoObj</span> <span class="variable">fromObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoObj</span>();</span><br><span class="line">  fromObj.setS(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  fromObj.setL(Lists.newArrayList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>));</span><br><span class="line">  <span class="type">DemoObj</span> <span class="variable">toObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoObj</span>();</span><br><span class="line">  org.apache.commons.beanutils.BeanUtils.copyProperties(toObj, fromObj);</span><br><span class="line">  toObj.setStr(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">  toObj.getList().add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">  System.out.println(JSON.toJSONString(fromObj));</span><br><span class="line">  System.out.println(JSON.toJSONString(toObj));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//&#123;&quot;list&quot;:[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;],&quot;str&quot;:&quot;a&quot;&#125;</span></span><br><span class="line"><span class="comment">//&#123;&quot;list&quot;:[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;],&quot;str&quot;:&quot;b&quot;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-springframework的beanutils"><a class="markdownIt-Anchor" href="#2-springframework的beanutils"></a> 2. springframework的BeanUtils</h3><p>所处的包：<code>org.springframework.beans.BeanUtils</code></p><p>提供了四个拷贝对象的方法，基本原理都一样，只不过是做了一些定制。这里只整理基本的拷贝方法：</p><ul><li><p><code>BeanUtils.copyProperties(Object source, Object target)</code></p><p>功能与apache的相似，需要注意的是，传入对象的顺序刚好相反，原对象在第一个，新对象在第二个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">springCopy</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">DemoObj</span> <span class="variable">fromObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoObj</span>();</span><br><span class="line">  fromObj.setStr(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  fromObj.setList(Lists.newArrayList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>));</span><br><span class="line">  <span class="type">DemoObj</span> <span class="variable">toObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoObj</span>();</span><br><span class="line">  org.springframework.beans.BeanUtils.copyProperties(fromObj, toObj);</span><br><span class="line">  toObj.setStr(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">  toObj.getList().add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">  System.out.println(JSON.toJSONString(fromObj));</span><br><span class="line">  System.out.println(JSON.toJSONString(toObj));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//&#123;&quot;list&quot;:[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;],&quot;str&quot;:&quot;a&quot;&#125;</span></span><br><span class="line"><span class="comment">//&#123;&quot;list&quot;:[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;],&quot;str&quot;:&quot;b&quot;&#125;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;前几天写代码的时候，需要拷贝对象，就使用了&lt;code&gt;org.apache.commons.beanutils.BeanUtils&lt;/code&gt;的&lt;code&gt;BeanUtils.copyProperties(Object dest, Object orig)&lt;/code&gt;拷贝对象，后面又修改了新对象的属性，就导致原对象也被修改了，仔细一研究才发现这个工具只是进行了浅拷贝。索性整理一下现在比较常用的一些深拷贝和浅拷贝工具。&lt;/p&gt;</summary>
    
    
    
    
    <category term="技术笔记" scheme="https://eoccc.gitee.io/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="踩坑" scheme="https://eoccc.gitee.io/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>dubbo优雅停机</title>
    <link href="https://eoccc.gitee.io/2022/05/14/dubbo%E4%BC%98%E9%9B%85%E5%81%9C%E6%9C%BA/"/>
    <id>https://eoccc.gitee.io/2022/05/14/dubbo%E4%BC%98%E9%9B%85%E5%81%9C%E6%9C%BA/</id>
    <published>2022-05-13T16:00:00.000Z</published>
    <updated>2023-03-10T10:52:57.408Z</updated>
    
    <content type="html"><![CDATA[<p>优雅停机是Dubbo的重要特性之一，因为核心业务运行时突然中断可能带来严重的后果。</p><span id="more"></span><p>Dubbo 是通过 JDK 的 ShutdownHook 来完成优雅停机的，所以如果用户使用 <code>kill -9 PID</code> 等强制关闭指令，是不会执行优雅停机的，只有通过 <code>kill PID</code> 时，才会执行。</p><p>Dubbo收到停机的指令后，会进行如下操作：</p><blockquote><ol><li>dubbo收到退出指令</li><li>provider端取消注册中心的元数据</li><li>注册中心将元数据的变更推送给consumer端</li><li>consumer端更新元数据（会移除准备停机的provider元数据）</li><li>providre端发送readonly报文通知consumer端服务不可用</li><li>providre端拒绝新的任务，等待正在执行的任务完成后断开连接</li></ol></blockquote><p><img src="https://gitee.com/eoccc/pic-shack/raw/master/image-20220630174211346.png" alt="image-20220630174211346"></p><p>第4步provider端主动发送报文同志consumer端服务下线，是为了避免第3步注册中心通知consumer端导致网络延迟。</p><p><code>DubboShutdownHook</code>在启动dubbo的时候注册到RunTime的hooks中去，源码位于<code>org.apache.dubbo.config.deploy.DefaultApplicationDeployer#registerShutdownHook</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">registerShutdownHook</span><span class="params">()</span> &#123;</span><br><span class="line">dubboShutdownHook.register();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//往下跟dubboShutdownHook.register()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (registered.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>) &amp;&amp; !ignoreListenShutdownHook) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Runtime.getRuntime().addShutdownHook(<span class="built_in">this</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">      logger.warn(<span class="string">&quot;register shutdown hook failed: &quot;</span> + e.getMessage());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      logger.warn(<span class="string">&quot;register shutdown hook failed: &quot;</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继续跟 Runtime.getRuntime().addShutdownHook</span></span><br><span class="line"><span class="comment">//这就到了java层了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addShutdownHook</span><span class="params">(Thread hook)</span> &#123;</span><br><span class="line">  <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">  <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">    sm.checkPermission(<span class="keyword">new</span> <span class="title class_">RuntimePermission</span>(<span class="string">&quot;shutdownHooks&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  ApplicationShutdownHooks.add(hook);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继续跟 ApplicationShutdownHooks.add</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Thread hook)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(hooks == <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Shutdown in progress&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (hook.isAlive())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Hook already running&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (hooks.containsKey(hook))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Hook previously registered&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//塞到了hooks这个map中</span></span><br><span class="line">  hooks.put(hook, hook);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用钩子：java.lang.ApplicationShutdownHooks#runHooks</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runHooks</span><span class="params">()</span> &#123;</span><br><span class="line">  Collection&lt;Thread&gt; threads;</span><br><span class="line">  <span class="keyword">synchronized</span>(ApplicationShutdownHooks.class) &#123;</span><br><span class="line">    threads = hooks.keySet();</span><br><span class="line">    hooks = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Thread hook : threads) &#123;</span><br><span class="line">    hook.start();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (Thread hook : threads) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      hook.join();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException x) &#123; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后调用钩子的入口是：java.lang.Runtime#exit</span></span><br></pre></td></tr></table></figure><p><code>DubboShutdownHook</code>都干了些啥呢？核心方法就一个<code>destroy()</code>，其中最重要的是<code>onDestroy()</code>，后续的大致就是移除了一些类加载器、spring容器、扩展类加载器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (destroyed.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//销毁前的操作，非常核心！</span></span><br><span class="line">      onDestroy();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//后面都是一些销毁容器的操作</span></span><br><span class="line">      HashSet&lt;ClassLoader&gt; copyOfClassLoaders = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(classLoaders);</span><br><span class="line">      <span class="keyword">for</span> (ClassLoader classLoader : copyOfClassLoaders) &#123;</span><br><span class="line">        removeClassLoader(classLoader);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (beanFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">        beanFactory.destroy();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (extensionDirector != <span class="literal">null</span>) &#123;</span><br><span class="line">        extensionDirector.destroy();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      LOGGER.error(<span class="string">&quot;Error happened when destroying ScopeModel.&quot;</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点看下<code>org.apache.dubbo.rpc.model.ApplicationModel#onDestroy</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 1. remove from frameworkModel</span></span><br><span class="line">  frameworkModel.removeApplication(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. pre-destroy, set stopping</span></span><br><span class="line">  <span class="keyword">if</span> (deployer != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// destroy registries and unregister services from registries first to notify consumers to stop consuming this instance.</span></span><br><span class="line">    <span class="comment">// 移除注册中心的元数据，以通过注册中心通知consumer停止调用服务，包括销毁服务发现、元数据等</span></span><br><span class="line">    deployer.preDestroy();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. Try to destroy protocols to stop this instance from receiving new requests from connections</span></span><br><span class="line">  <span class="comment">// 销毁协议，从而停止接收新的请求</span></span><br><span class="line">  frameworkModel.tryDestroyProtocols();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. destroy application resources</span></span><br><span class="line">  <span class="keyword">for</span> (ModuleModel moduleModel : <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(moduleModels)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (moduleModel != internalModule) &#123;</span><br><span class="line">      moduleModel.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 5. destroy internal module later</span></span><br><span class="line">  internalModule.destroy();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 6. post-destroy, release registry resources</span></span><br><span class="line">  <span class="keyword">if</span> (deployer != <span class="literal">null</span>) &#123;</span><br><span class="line">    deployer.postDestroy();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 7. destroy other resources (e.g. ZookeeperTransporter )</span></span><br><span class="line">  notifyDestroy();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (environment != <span class="literal">null</span>) &#123;</span><br><span class="line">    environment.destroy();</span><br><span class="line">    environment = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (configManager != <span class="literal">null</span>) &#123;</span><br><span class="line">    configManager.destroy();</span><br><span class="line">    configManager = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (serviceRepository != <span class="literal">null</span>) &#123;</span><br><span class="line">    serviceRepository.destroy();</span><br><span class="line">    serviceRepository = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 8. destroy framework if none application</span></span><br><span class="line">  frameworkModel.tryDestroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;优雅停机是Dubbo的重要特性之一，因为核心业务运行时突然中断可能带来严重的后果。&lt;/p&gt;</summary>
    
    
    
    
    <category term="中间件" scheme="https://eoccc.gitee.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="dubbo" scheme="https://eoccc.gitee.io/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出对比数组和链表</title>
    <link href="https://eoccc.gitee.io/2022/05/07/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AF%B9%E6%AF%94%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/"/>
    <id>https://eoccc.gitee.io/2022/05/07/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AF%B9%E6%AF%94%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/</id>
    <published>2022-05-07T08:25:19.000Z</published>
    <updated>2023-01-12T02:40:27.797Z</updated>
    
    <content type="html"><![CDATA[<p>数组和链表是我们日常编程中非常常用的两种数据结构，那么它们的性能表现如何，本文由浅入深对此进行一些分析。</p><span id="more"></span><h2 id="内存分配"><a class="markdownIt-Anchor" href="#内存分配"></a> 内存分配</h2><p>在开始分析之前，我们先来了解一下数组和链表在内存中的存储方式。</p><p>数组在内存中是存储在一个连续的空间。对于基础数据类型，数组的元素存储的是数据本身，对于引用类型，元素存储的是引用地址（一个Integer值）。在为数组由两部分组成：数组的元数据（16字节）、数组的元素（基本数据类型为元素本身大小，引用类型为引用地址–8个字节）。</p><p>链表在内存中是分布在非连续的空间中的，通过地址指针指向下一个或上一个节点。</p><p><img src="https://gitee.com/eoccc/pic-shack/raw/master/image-20220610090434150.png" alt="image-20220610090434150"></p><p>在64位jvm中，内存页为内存分配的最小单位，每个内存页的大小为8个字节。因此，在为对象分配内存的时候，必须为8的倍数，如果元素占用的内存小于8个字节，也会分配8个字节。如：</p><blockquote><ol><li><code>new int[1]</code>的大小为24个字节，即元素int的4个字节 + 4个空白字节（因为一个内存页为8个字节，） + 数组内部属性16个字节；</li><li><code>new long[1]</code>的大小为24个字节，即元素long的8个字节 + 数组内部属性16个字节；</li><li><code>new Node[1]</code>将会分配24个字节，即引用地址Integer的4个字节 + 4个空白字节 + 数组内部属性16个字节</li></ol></blockquote><p>接下来我们进行测试：我们分别对boolean、int、long、Node对象新建容量从1～10的数组，然后分别统计每个数组占用内存的大小。</p><p>这里我使用jol的ClassLayout工具获取对象占用的内存大小，引入依赖即可使用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;capacity booleanArraySize intArraySize longArraySize nodeArraySize&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="type">boolean</span>[] booleanArray = <span class="keyword">new</span> <span class="title class_">boolean</span>[i];</span><br><span class="line">    <span class="type">int</span>[] intArray = <span class="keyword">new</span> <span class="title class_">int</span>[i];</span><br><span class="line">    <span class="type">long</span>[] longArray = <span class="keyword">new</span> <span class="title class_">long</span>[i];</span><br><span class="line">    Node[] nodeArray = <span class="keyword">new</span> <span class="title class_">Node</span>[i];</span><br><span class="line">    <span class="type">long</span> <span class="variable">booleanArraySize</span> <span class="operator">=</span> ClassLayout.parseInstance(booleanArray).instanceSize();</span><br><span class="line">    <span class="type">long</span> <span class="variable">intArraySize</span> <span class="operator">=</span> ClassLayout.parseInstance(intArray).instanceSize();</span><br><span class="line">    <span class="type">long</span> <span class="variable">longArraySize</span> <span class="operator">=</span> ClassLayout.parseInstance(longArray).instanceSize();</span><br><span class="line">    <span class="type">long</span> <span class="variable">nodeArraySize</span> <span class="operator">=</span> ClassLayout.parseInstance(nodeArray).instanceSize();</span><br><span class="line">    System.out.printf(<span class="string">&quot;%d %d %d %d %d%n&quot;</span>, i, booleanArraySize, intArraySize, longArraySize, nodeArraySize);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Node pre;</span><br><span class="line">  <span class="keyword">private</span> Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>统计的结果如下表所示。如boolean数组，初始大小为24字节，除去数组自身的16字节以外，还有8个字节可以用来保存元素，boolean占用1个字节，也就是说还可以存8个boolean元素，正如实验结果一样，数组容量为1～8的时候，占用内存为24字节，当数组容量为9的时候变成32字节（24+8，即增加了一个内存页）。</p><table><thead><tr><th>capacity</th><th>booleanArraySize</th><th>intArraySize</th><th>longArraySize</th><th>nodeArraySize</th></tr></thead><tbody><tr><td>1</td><td>24</td><td>24</td><td>24</td><td>24</td></tr><tr><td>2</td><td>24</td><td>24</td><td>32</td><td>24</td></tr><tr><td>3</td><td>24</td><td>32</td><td>40</td><td>32</td></tr><tr><td>4</td><td>24</td><td>32</td><td>48</td><td>32</td></tr><tr><td>5</td><td>24</td><td>40</td><td>56</td><td>40</td></tr><tr><td>6</td><td>24</td><td>40</td><td>64</td><td>40</td></tr><tr><td>7</td><td>24</td><td>48</td><td>72</td><td>48</td></tr><tr><td>8</td><td>24</td><td>48</td><td>80</td><td>48</td></tr><tr><td>9</td><td>32</td><td>56</td><td>88</td><td>56</td></tr><tr><td>10</td><td>32</td><td>56</td><td>96</td><td>56</td></tr></tbody></table><h2 id="添加"><a class="markdownIt-Anchor" href="#添加"></a> 添加</h2><p><strong>数组插入</strong></p><p>对于数组来说，在末尾添加一个元素的流程大致是这样的：</p><blockquote><ol><li>找到数组在内存中的起始地址；</li><li>根据下标计算出需要插入元素的位置的地址；</li><li>如果是基本数据类型，直接将元素写入到内存中；</li><li>如果是引用类型，将元素的地址写入到需要添加元素的内存地址</li></ol></blockquote><p>如下图是一个容量为3的int数组的示例，数组中已经保存了两个元素，由于是基本类型，没有赋值的元素（即第三个元素）会初始化为0。数组在内存中的起始地址为1000，metadate占16字节，因此第一个元素的起始位置是1016，由于内存页为8个字节，保存3个元素需要两个内存页，因此数组的结束位置为1032。</p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h35mtp6f6ej20iy066q32.jpg" alt="image-20220609103236268" style="zoom:67%;"><p>如果要在第三个位置添加一个元素，即如下操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array[<span class="number">2</span>] = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>那么会进行如下操作：</p><blockquote><ol><li>找到数组在内存中的位置1000</li><li>计算出需要插入的元素的位置：1000 + 16 + 4 * 2 = 1024</li><li>判断地址是否超出数组分配的内存地址范围，超出则说明数组越界，抛出<em>IndexOutOfBoundsException</em></li><li>将需要插入的值写入到指定的内存位置</li></ol></blockquote><p><strong>链表添加元素</strong></p><p>链表添加元素就比较简单，直接把Node的引用地址赋值给末尾Node的next即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail.next = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br></pre></td></tr></table></figure><p><strong>性能分析</strong></p><p>数组追加元素比链表追加元素要多两个操作：计算元素的位置、判断是否越界。因此我猜测链表添加元素的速度要快一些。测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAdd</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxCount</span> <span class="operator">=</span> <span class="number">1000000</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;count    array add cost&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (count &lt; maxCount) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        arrayAdd(count);</span><br><span class="line">        System.out.println(count + <span class="string">&quot;    &quot;</span> + (System.nanoTime() - start));</span><br><span class="line">        count = count &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;count    link add cost&quot;</span>);</span><br><span class="line">    count = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &lt; maxCount) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        linkAdd(count);</span><br><span class="line">        System.out.println(count + <span class="string">&quot;    &quot;</span> + (System.nanoTime() - start));</span><br><span class="line">        count = count &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node[] arrayAdd(<span class="type">int</span> count) &#123;</span><br><span class="line">    Node[] nodes = <span class="keyword">new</span> <span class="title class_">Node</span>[count];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        nodes[i] = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nodes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">linkAdd</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        tmp.next = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析一下数据，如下图，横坐标是元素的数量，纵坐标是耗时（纳秒）。可以看到，在一定数量范围内，数组追加元素的速度比链表要快一些，但是超过一定的数据量后，链表要快一些。</p><p><img src="https://gitee.com/eoccc/pic-shack/raw/master/image-20220610092601983.png" alt="image-20220610092601983"></p><p>图中add的耗时存在一个先增后降的过程，这里可能涉及到jvm和操作系统更底层的实现逻辑了，暂时没有分析出原因。</p><h2 id="插入"><a class="markdownIt-Anchor" href="#插入"></a> 插入</h2><p><strong>数组插入</strong></p><p>数组的插入是一个比较重的操作，大致流程如下：</p><blockquote><ol><li>根据下标定位到需要插入的内存地址（通过偏移量计算）</li><li>将后面的元素往后移动一个位置（涉及到大块的内存移动）</li><li>将新的元素写到指定的位置</li></ol></blockquote><p>数组插入代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">arrayInsert</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> currSize, Node[] nodes, Node node)</span> &#123;</span><br><span class="line">    <span class="comment">//先把后面的元素后移一位</span></span><br><span class="line">    <span class="keyword">while</span> (currSize &gt; index) &#123;</span><br><span class="line">        nodes[currSize] = nodes[currSize - <span class="number">1</span>];</span><br><span class="line">        currSize--;</span><br><span class="line">    &#125;</span><br><span class="line">    nodes[index] = node;</span><br><span class="line">    <span class="keyword">return</span> currSize+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>链表插入</strong></p><p>链表的插入比较简单，只需要修改链表的指针即可，而且只需要修改2个节点的指针（双向链表需要修改3个节点的指针）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单向链表插入</span></span><br><span class="line"><span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> pre.next;</span><br><span class="line">pre.next = node;</span><br><span class="line">node.next = next;</span><br></pre></td></tr></table></figure><p>但是如果我们只知道要插入到第几个，还得先通过遍历定位出插入节点的位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">linkInsert</span><span class="params">(<span class="type">int</span> index, Node head, Node node)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">//先找到插入的位置</span></span><br><span class="line">    <span class="keyword">while</span> (index &gt; <span class="number">0</span> &amp;&amp; tmp != <span class="literal">null</span>) &#123;</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">        index--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//越界了</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> tmp.next;</span><br><span class="line">    tmp.next = node;</span><br><span class="line">    node.next = next;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>性能对比</strong></p><p>链表不涉及内存的移动，只需要定位到插入的位置即可，复杂度为O(index)，因此我猜测链表的插入速度要快一些。我们测试在size/2的位置插入元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxSize</span> <span class="operator">=</span> <span class="number">1000000</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">currSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    Node[] nodes = <span class="keyword">new</span> <span class="title class_">Node</span>[maxSize];</span><br><span class="line">    nodes[<span class="number">0</span>] = head;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">tail</span> <span class="operator">=</span> head;</span><br><span class="line">    tail = addElement(nodes, tail, <span class="number">0</span>, size);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;count    array insert cost    link insert cost&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (size &lt; maxSize) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> size &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        currSize = arrayInsert(index, currSize, nodes, node);</span><br><span class="line">        System.out.print(size + <span class="string">&quot;    &quot;</span> + (System.nanoTime() - start));</span><br><span class="line"></span><br><span class="line">        start = System.nanoTime();</span><br><span class="line">        linkInsert(index, head, node);</span><br><span class="line">        System.out.println(<span class="string">&quot;    &quot;</span> + (System.nanoTime() - start));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        size = size &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; maxSize) &#123;</span><br><span class="line">            tail = addElement(nodes, tail, currSize, size);</span><br><span class="line">            currSize++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><p><img src="/.io//image-20220610092601983.png" alt="image-20220610092601983"></p><h2 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h2><p>删除和插入类似，数组会导致内存块的移动，链表只需要修改节点的指针即可，这里不再赘述。</p><h2 id="遍历"><a class="markdownIt-Anchor" href="#遍历"></a> 遍历</h2><p>数组的遍历需要根据下标，计算出元素的地址，然后取出元素。链表的遍历依次获取元素的地址指针即可。但是由于数组在内存中是顺序保存的，操作系统加载数据的时候，会把缓存页中的数据全都加载到高速缓存，因此数据的遍历速度会比链表快。</p><p>上代码测试分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFor</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;Integer, List&lt;Long&gt;&gt; arrayCostMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Map&lt;Integer, List&lt;Long&gt;&gt; linkCostMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxSize</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">currSize</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//为了削弱机器获胜虚拟机导致的误差，跑了10次取平均值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (currSize &lt; maxSize) &#123;</span><br><span class="line">            Node[] nodeArray = createArray(currSize);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> createLink(nodeArray);</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; currSize; i++) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nodeArray[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">arrayCost</span> <span class="operator">=</span> System.nanoTime() - start;</span><br><span class="line">            List&lt;Long&gt; arrayCostList = arrayCostMap.computeIfAbsent(currSize, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            arrayCostList.add(arrayCost);</span><br><span class="line"></span><br><span class="line">            start = System.nanoTime();</span><br><span class="line">            <span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">while</span> (tmp != <span class="literal">null</span>) &#123;</span><br><span class="line">                tmp = tmp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">linkCost</span> <span class="operator">=</span> System.nanoTime() - start;</span><br><span class="line">            List&lt;Long&gt; linkCostList = linkCostMap.computeIfAbsent(currSize, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            linkCostList.add(linkCost);</span><br><span class="line">            currSize = currSize &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    currSize = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (currSize &lt; maxSize) &#123;</span><br><span class="line">        <span class="type">Double</span> <span class="variable">arrayCost</span> <span class="operator">=</span> arrayCostMap.get(currSize).stream().collect(Collectors.averagingLong(Long::<span class="keyword">new</span>));</span><br><span class="line">        <span class="type">Double</span> <span class="variable">linkCost</span> <span class="operator">=</span> linkCostMap.get(currSize).stream().collect(Collectors.averagingLong(Long::<span class="keyword">new</span>));</span><br><span class="line">        System.out.printf(<span class="string">&quot;%d %s %s%n&quot;</span>, currSize, arrayCost, linkCost);</span><br><span class="line">        currSize = currSize &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node[] createArray(<span class="type">int</span> size) &#123;</span><br><span class="line">    Node[] nodeArray = <span class="keyword">new</span> <span class="title class_">Node</span>[size];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        nodeArray[i] = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nodeArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">createLink</span><span class="params">(Node[] nodeArray)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">for</span> (Node node : nodeArray) &#123;</span><br><span class="line">        tmp.next = node;</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果分析如下图。整体来说，数组的遍历速度比链表快，尤其是在数据量比较大的时候，二者的差距越来越大。不过在前面数组和链表的遍历数组都有波动，猜测跟jvm、操作系统、硬件都有关系，感兴趣的可以和我一起研究。</p><p><img src="https://gitee.com/eoccc/pic-shack/raw/master/image-20220612181316593.png" alt="image-20220612181316593"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;数组和链表是我们日常编程中非常常用的两种数据结构，那么它们的性能表现如何，本文由浅入深对此进行一些分析。&lt;/p&gt;</summary>
    
    
    
    
    <category term="随笔" scheme="https://eoccc.gitee.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>dubbo服务暴露</title>
    <link href="https://eoccc.gitee.io/2022/05/04/dubbo%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2/"/>
    <id>https://eoccc.gitee.io/2022/05/04/dubbo%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2/</id>
    <published>2022-05-03T16:00:00.000Z</published>
    <updated>2022-08-01T04:58:42.247Z</updated>
    
    <content type="html"><![CDATA[<p>Dubbo的服务暴露主要分为两个部分：第一步，将服务实例通过代理转换成Invoker；第二步，将Invoker通过具体协议转换成Exporter，实现服务暴露。</p><span id="more"></span><p>Dubbo框架进行服务暴露的入口是ServiceConfig#export，暴露服务的流程大致分为以下几步：</p><blockquote><ol><li>读取配置。AbstractConfig#refresh</li><li>通过代理将服务实例转成invoker。默认是Javassist，也支持JDK动态代理。ServiceConfig#doExportUrl</li><li>通过具体的协议，将Invoker转成expoter</li><li>将服务的元数据注册到注册中心。ServiceConfig#exported</li></ol></blockquote><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3wc0ircowj20xo0rqwhl.jpg" style="zoom:33%;"><p>注意：</p><ol><li>在将服务的元数据推送到注册中心的时候，如果失败了会进行重试，默认重试次数为6次。</li><li>支持多注册中心。MetadataServiceNameMapping#map</li></ol><p><strong>配置文件优先级：</strong></p><blockquote><ol><li>-D 传递给 JVM 参数优先级最高，比如-Ddubbo. protocol.port=20880</li><li>代码或XML配置优先级次高，比如Spring中XML文件指定&lt;dubbo:protocol port=H20880’/&gt;</li><li>置文件优先级最低，比如 dubbo.properties 文件指定 dubbo.protocol.port=20880</li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;Dubbo的服务暴露主要分为两个部分：第一步，将服务实例通过代理转换成Invoker；第二步，将Invoker通过具体协议转换成Exporter，实现服务暴露。&lt;/p&gt;</summary>
    
    
    
    
    <category term="中间件" scheme="https://eoccc.gitee.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="dubbo" scheme="https://eoccc.gitee.io/tags/dubbo/"/>
    
  </entry>
  
</feed>
